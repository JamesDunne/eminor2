Disassembly Listing for HID Bootloader - PIC18 Non-J
Generated From:
C:/sw/github/eminor2/v2/controller/PIC_BOOT/dist/PIC18F4550/debug/PIC_BOOT.debug.cof
Dec 11, 2013 9:08:59 AM

---  E:/c18v3.46/pic18-lt/cxx-framework/src/traditional/proc/p18f4550.asm  ------------------------------
0F7E  0E00     MOVLW 0x0
0F80  6EF3     MOVWF PRODL, ACCESS
0F82  EE00     LFSR 0, 0x0
0F84  F000     NOP
0F86  0E08     MOVLW 0x8
0F88  D801     RCALL zero_block
0F8A  0012     RETURN 0
0F8C  60EA     CPFSLT FSR0H, ACCESS
0F8E  D002     BRA compare_l
0F90  6AEE     CLRF POSTINC0, ACCESS
0F92  D7FC     BRA zero_block
0F94  50F3     MOVF PRODL, W, ACCESS
0F96  60E9     CPFSLT FSR0L, ACCESS
0F98  0012     RETURN 0
0F9A  6AEE     CLRF POSTINC0, ACCESS
0F9C  D7FC     BRA loop_l
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/usbdrv.c  ----------------------------------------------
1:             /*********************************************************************
2:              *
3:              *                Microchip USB C18 HID Bootloader usbdrv.c
4:              *			(modified from usbdrv.c included in MCHPFSUSB v1.2/v1.3)
5:              *
6:              *********************************************************************
7:              * FileName:        usbdrv.c
8:              * Dependencies:    See INCLUDES section below
9:              * Processor:       PIC18
10:             * Compiler:        C18 3.30+
11:             * Company:         Microchip Technology, Inc.
12:             *
13:             * Software License Agreement
14:             *
15:             * The software supplied herewith by Microchip Technology Incorporated
16:             * (the "Company") for its PICmicro(R) Microcontroller is intended and
17:             * supplied to you, the Company's customer, for use solely and
18:             * exclusively on Microchip PICmicro Microcontroller products. The
19:             * software is owned by the Company and/or its supplier, and is
20:             * protected under applicable copyright laws. All rights are reserved.
21:             * Any use in violation of the foregoing restrictions may subject the
22:             * user to criminal sanctions under applicable laws, as well as to
23:             * civil liability for the breach of the terms and conditions of this
24:             * license.
25:             *
26:             * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
27:             * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
28:             * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
29:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
30:             * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
31:             * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
32:             *
33:             * File version         Date        Comment
34:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
35:             * 1.0                  11/19/04    Original.
36:             * 1.2                  08/14/07    Bug fixes.
37:             * 1.4          		05/31/07	A few non-critical changes made to
38:             *									decrease code size for use in
39:             *									bootloader application.
40:             * 1.5                  05/07/09	Small update to work with the
41:             *									new usbctrltrf.c file.
42:             * 1.6                  06/10/13    Minor cleanup and optimization.
43:             ********************************************************************/
44:            
45:            /** I N C L U D E S **********************************************************/
46:            #include <p18cxxx.h>
47:            #include "typedefs.h"
48:            #include "usb.h"
49:            #include "io_cfg.h"             // Required for USBCheckBusStatus()
50:            
51:            /** V A R I A B L E S ********************************************************/
52:            #pragma udata
53:            byte bTRNIFCount;               // Bug fix - Work around.
54:            
55:            /** P R I V A T E  P R O T O T Y P E S ***************************************/
56:            //void USBModuleEnable(void);   //Using below macro instead for space savings.
57:            #define USBModuleEnable()   {UCON = 0; UIE = 0; UCONbits.USBEN = 1; usb_device_state = ATTACHED_STATE;}
58:            
59:            void USBModuleDisable(void);
60:            
61:            void USBSuspend(void);
62:            void USBWakeFromSuspend(void);
63:            
64:            void USBProtocolResetHandler(void);
65:            void USB_SOF_Handler(void);
66:            void USBStallHandler(void);
67:            void USBErrorHandler(void);
68:            
69:            void ClearWatchdog(void);
70:            
71:            /** D E C L A R A T I O N S **************************************************/
72:            #pragma code
73:            /******************************************************************************
74:             * Function:        void USBCheckBusStatus(void)
75:             *
76:             * PreCondition:    None
77:             *
78:             * Input:           None
79:             *
80:             * Output:          None
81:             *
82:             * Side Effects:    None
83:             *
84:             * Overview:        This routine enables/disables the USB module by monitoring
85:             *                  the USB power signal.
86:             *
87:             * Note:            None
88:             *****************************************************************************/
89:            void USBCheckBusStatus(void)
90:            {
91:                /**************************************************************************
92:                 * Bus Attachment & Detachment Detection
93:                 * usb_bus_sense is an i/o pin defined in io_cfg.h
94:                 *************************************************************************/
95:                #define USB_BUS_ATTACHED    1
96:                #define USB_BUS_DETACHED    0
97:            
98:                #ifdef USE_USB_BUS_SENSE_IO
99:                    if(usb_bus_sense == USB_BUS_ATTACHED)       // Is USB bus attached?
100:                   {
101:                       if(UCONbits.USBEN == 0)                 // Is the module off?
102:                           USBModuleEnable();                  // Is off, enable it
103:                   }
104:                   else
105:                   {
106:                       if(UCONbits.USBEN == 1)                 // Is the module on?
107:                       {
108:                           UCON = 0;                               // Disable module & detach from bus
109:                           UIE = 0;                                // Mask all USB interrupts
110:                           usb_device_state = DETACHED_STATE;      // Defined in usbmmap.c & .h
111:                       }
112:                   }//end if(usb_bus_sense...)
113:               #else
114:                   if(UCONbits.USBEN == 0)                 // Is the module off?
0D64  B66D     BTFSC UCON, 3, ACCESS
0D66  D006     BRA 0xD74
115:                       USBModuleEnable();                  // Is off, enable it
0D68  6A6D     CLRF UCON, ACCESS
0D6A  6A69     CLRF UIE, ACCESS
0D6C  866D     BSF UCON, 3, ACCESS
0D6E  0102     MOVLB 0x2
0D70  0E01     MOVLW 0x1
0D72  6FB4     MOVWF 0xB4, BANKED
116:               #endif
117:           
118:           
119:               /*
120:                * After enabling the USB module, it takes some time for the voltage
121:                * on the D+ or D- line to rise high enough to get out of the SE0 condition.
122:                * The USB Reset interrupt should not be unmasked until the SE0 condition is
123:                * cleared. This helps preventing the firmware from misinterpreting this
124:                * unique event as a USB bus reset from the USB host.
125:                */
126:               if(usb_device_state == ATTACHED_STATE)
0D74  0102     MOVLB 0x2
0D76  05B4     DECF 0xB4, W, BANKED
0D78  E108     BNZ 0xD8A
127:               {
128:                   if(!UCONbits.SE0)
0D7A  BA6D     BTFSC UCON, 5, ACCESS
0D7C  D006     BRA 0xD8A
129:                   {
130:                       UIR = 0;                        // Clear all USB interrupts
0D7E  6A68     CLRF UIR, ACCESS
131:                       UIE = 0;                        // Mask all USB interrupts
0D80  6A69     CLRF UIE, ACCESS
132:                       UIEbits.URSTIE = 1;             // Unmask RESET interrupt
0D82  8069     BSF UIE, 0, ACCESS
133:                       UIEbits.IDLEIE = 1;             // Unmask IDLE interrupt
0D84  8869     BSF UIE, 4, ACCESS
134:                       usb_device_state = POWERED_STATE;
0D86  0E02     MOVLW 0x2
0D88  6FB4     MOVWF 0xB4, BANKED
135:                   }//end if                           // else wait until SE0 is cleared
136:               }//end if(usb_device_state == ATTACHED_STATE)
137:           
138:           }//end USBCheckBusStatus
0D8A  0012     RETURN 0
139:           
140:           /******************************************************************************
141:            * Function:        void USBModuleEnable(void)
142:            *
143:            * PreCondition:    None
144:            *
145:            * Input:           None
146:            *
147:            * Output:          None
148:            *
149:            * Side Effects:    None
150:            *
151:            * Overview:        This routine enables the USB module.
152:            *                  An end designer should never have to call this routine
153:            *                  manually. This routine should only be called from
154:            *                  USBCheckBusStatus().
155:            *
156:            * Note:            See USBCheckBusStatus() for more information.
157:            *****************************************************************************/
158:           //void USBModuleEnable(void)
159:           //{
160:           //    UCON = 0;
161:           //    UIE = 0;                                // Mask all USB interrupts
162:           //    UCONbits.USBEN = 1;                     // Enable module & attach to bus
163:           //    usb_device_state = ATTACHED_STATE;      // Defined in usbmmap.c & .h
164:           //}//end USBModuleEnable
165:           
166:           
167:           /******************************************************************************
168:            * Function:        void USBModuleDisable(void)
169:            *
170:            * PreCondition:    None
171:            *
172:            * Input:           None
173:            *
174:            * Output:          None
175:            *
176:            * Side Effects:    None
177:            *
178:            * Overview:        This routine disables the USB module.
179:            *                  An end designer should never have to call this routine
180:            *                  manually. This routine should only be called from
181:            *                  USBCheckBusStatus().
182:            *
183:            * Note:            See USBCheckBusStatus() for more information.
184:            *****************************************************************************/
185:           //void USBModuleDisable(void)
186:           //{
187:           //    UCON = 0;                               // Disable module & detach from bus
188:           //    UIE = 0;                                // Mask all USB interrupts
189:           //    usb_device_state = DETACHED_STATE;      // Defined in usbmmap.c & .h
190:           //}//end USBModuleDisable
191:           
192:           ///******************************************************************************
193:           // * Function:        void USBSoftDetach(void)
194:           // *
195:           // * PreCondition:    None
196:           // *
197:           // * Input:           None
198:           // *
199:           // * Output:          None
200:           // *
201:           // * Side Effects:    The device will have to be re-enumerated to function again.
202:           // *
203:           // * Overview:        USBSoftDetach electrically disconnects the device from
204:           // *                  the bus. This is done by stop supplying Vusb voltage to
205:           // *                  pull-up resistor. The pull-down resistors on the host
206:           // *                  side will pull both differential signal lines low and
207:           // *                  the host registers the event as a disconnect.
208:           // *
209:           // *                  Since the USB cable is not physically disconnected, the
210:           // *                  power supply through the cable can still be sensed by
211:           // *                  the device. The next time USBCheckBusStatus() function
212:           // *                  is called, it will reconnect the device back to the bus.
213:           // *
214:           // * Note:            None
215:           // *****************************************************************************/
216:           //void USBSoftDetach(void)
217:           //{
218:           //    USBModuleDisable();
219:           //}//end USBSoftDetach
220:           
221:           /******************************************************************************
222:            * Function:        void USBDriverService(void)
223:            *
224:            * PreCondition:    None
225:            *
226:            * Input:           None
227:            *
228:            * Output:          None
229:            *
230:            * Side Effects:    None
231:            *
232:            * Overview:        This routine is the heart of this firmware. It manages
233:            *                  all USB interrupts.
234:            *
235:            * Note:            Device state transitions through the following stages:
236:            *                  DETACHED -> ATTACHED -> POWERED -> DEFAULT ->
237:            *                  ADDRESS_PENDING -> ADDRESSED -> CONFIGURED -> READY
238:            *****************************************************************************/
239:           void USBDriverService(void)
240:           {
241:               /*
242:                * Pointless to continue servicing if USB cable is not even attached.
243:                */
244:               if(usb_device_state == DETACHED_STATE) return;
0D8C  0102     MOVLB 0x2
0D8E  51B4     MOVF 0xB4, W, BANKED
0D90  E101     BNZ 0xD94
0D92  0012     RETURN 0
245:           
246:               /*
247:                * Task A: Service USB Activity Interrupt
248:                */
249:           
250:           //    if(UIRbits.ACTVIF && UIEbits.ACTVIE)    USBWakeFromSuspend();
251:               if(UIRbits.ACTVIF)    USBWakeFromSuspend();
0D94  B468     BTFSC UIR, 2, ACCESS
0D96  D845     RCALL USBWakeFromSuspend
252:           
253:               /*
254:                * Pointless to continue servicing if the device is in suspend mode.
255:                */
256:               if(UCONbits.SUSPND==1) return;
0D98  B26D     BTFSC UCON, 1, ACCESS
0D9A  0012     RETURN 0
257:           
258:               /*
259:                * Task B: Service USB Bus Reset Interrupt.
260:                * When bus reset is received during suspend, ACTVIF will be set first,
261:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
262:                * This is why URSTIF is checked after ACTVIF.
263:                */
264:           //    if(UIRbits.URSTIF && UIEbits.URSTIE)    USBProtocolResetHandler();
265:               if(UIRbits.URSTIF)    USBProtocolResetHandler();
0D9C  B068     BTFSC UIR, 0, ACCESS
0D9E  D858     RCALL USBProtocolResetHandler
266:           
267:               /*
268:                * Task C: Service other USB interrupts
269:                */
270:           //    if(UIRbits.IDLEIF && UIEbits.IDLEIE)    USBSuspend();
271:               if(UIRbits.IDLEIF)    USBSuspend();
0DA0  B868     BTFSC UIR, 4, ACCESS
0DA2  D817     RCALL USBSuspend
272:           
273:           //    if(UIRbits.SOFIF && UIEbits.SOFIE)      USB_SOF_Handler();
274:           //    if(UIRbits.STALLIF && UIEbits.STALLIE)  USBStallHandler();
275:               if(UIRbits.STALLIF)  USBStallHandler();
0DA4  BA68     BTFSC UIR, 5, ACCESS
0DA6  D844     RCALL USBStallHandler
276:           
277:           
278:           //    if(UIRbits.UERRIF && UIEbits.UERRIE)    USBErrorHandler();
279:           
280:               /*
281:                * Pointless to continue servicing if the host has not sent a bus reset.
282:                * Once bus reset is received, the device transitions into the DEFAULT
283:                * state and is ready for communication.
284:                */
285:               if(usb_device_state < DEFAULT_STATE) return;
0DA8  0E03     MOVLW 0x3
0DAA  0102     MOVLB 0x2
0DAC  5DB4     SUBWF 0xB4, W, BANKED
0DAE  E201     BC 0xDB2
0DB0  0012     RETURN 0
286:           
287:               /*
288:                * Task D: Servicing USB Transaction Complete Interrupt
289:                */
290:               for(bTRNIFCount = 0; bTRNIFCount < 4; bTRNIFCount++)
0DB2  0102     MOVLB 0x2
0DB4  6BAF     CLRF 0xAF, BANKED
0DB6  0E04     MOVLW 0x4
0DB8  5DAF     SUBWF 0xAF, W, BANKED
0DBA  E20A     BC 0xDD0
0DCA  0102     MOVLB 0x2
0DCC  2BAF     INCF 0xAF, F, BANKED
0DCE  D7F3     BRA 0xDB6
291:               {
292:           //        if(UIRbits.TRNIF && UIEbits.TRNIE)
293:                   if(UIRbits.TRNIF)
0DBC  A668     BTFSS UIR, 3, ACCESS
0DBE  D008     BRA 0xDD0
294:                   {
295:                       /*
296:                        * USBCtrlEPService only services transactions over EP0.
297:                        * It ignores all other EP transactions.
298:                        */
299:                       if(USBCtrlEPService() == 0) // If not an EP0 transaction, then clear TRNIF.
0DC0  EC48     CALL 0x690, 0
0DC2  F003     NOP
0DC4  0900     IORLW 0x0
0DC6  E101     BNZ 0xDCA
300:                       {
301:                           /*
302:           		         * Other EP can be serviced later by responsible device class firmware.
303:           		         * Each device driver knows when an OUT or IN transaction is ready by
304:           		         * checking the buffer ownership bit.
305:           		         * An OUT EP should always be owned by SIE until the data is ready.
306:           		         * An IN EP should always be owned by CPU until the data is ready.
307:           		         *
308:           		         * Because of this logic, it is not necessary to save the USTAT value
309:           		         * of non-EP0 transactions.
310:           		         */
311:           		        UIRbits.TRNIF = 0;
0DC8  9668     BCF UIR, 3, ACCESS
312:           		        /*
313:           		         * At least five Tcy are needed in between clearing UIR<TRNIF>
314:           		         * and when it becomes reasserted when the USTAT FIFO has more
315:           		         * than one entry in it.
316:           		         *
317:           		         * No Nops are needed here because the number of instruction
318:           		         * cycles between clearing the TRNIF here to the next flag
319:           		         * check is longer than the required minimum of six Tcy due
320:           		         * to the for loop logic of bTRNIFCount. This is true even
321:           		         * when all optimization options in C18 are enabled.
322:           		         */
323:                       }
324:                   }//end if(UIRbits.TRNIF && UIEbits.TRNIE)
325:                   else
326:                       break;
327:               }// end for(bTRNIFCount = 0; bTRNIFCount < 4; bTRNIFCount++)
328:           
329:           }//end USBDriverService
0DD0  0012     RETURN 0
330:           
331:           /******************************************************************************
332:            * Function:        void USBSuspend(void)
333:            *
334:            * PreCondition:    None
335:            *
336:            * Input:           None
337:            *
338:            * Output:          None
339:            *
340:            * Side Effects:    None
341:            *
342:            * Overview:		When the USB host sends USB suspend signalling, this function
343:            *					gets called.  In order to be USB compliant, the device 
344:            *					firmware should configure the application so that it takes
345:            *					no more than 2.5mA from the +5VBus supply from the
346:            *					USB port during USB suspend events.  Bus powered devices can
347:            *					meet this by suspending the USB module, and either clock switching
348:            *					to a low frequency or sleeping.  This is not necessary if the
349:            *					application is self powered, or if it doesn't need to meet
350:            *					all USB compliance requirements.
351:            *
352:            * Note:            None
353:            *****************************************************************************/
354:           void USBSuspend(void)
355:           {
356:           	static unsigned char UIESave;
357:           	
358:               /*
359:                * NOTE: Do not clear UIRbits.ACTVIF here!
360:                * Reason:
361:                * ACTVIF is only generated once an IDLEIF has been generated.
362:                * This is a 1:1 ratio interrupt generation.
363:                * For every IDLEIF, there will be only one ACTVIF regardless of
364:                * the number of subsequent bus transitions.
365:                *
366:                * If the ACTIF is cleared here, a problem could occur when:
367:                * [       IDLE       ][bus activity ->
368:                * <--- 3 ms ----->     ^
369:                *                ^     ACTVIF=1
370:                *                IDLEIF=1
371:                *  #           #           #           #   (#=Program polling flags)
372:                *                          ^
373:                *                          This polling loop will see both
374:                *                          IDLEIF=1 and ACTVIF=1.
375:                *                          However, the program services IDLEIF first
376:                *                          because ACTIVIE=0.
377:                *                          If this routine clears the only ACTIVIF,
378:                *                          then it can never get out of the suspend
379:                *                          mode.
380:                */
381:           
382:               /* Modifiable Section */
383:               /*
384:                * At this point the PIC can go into sleep,idle, or
385:                * switch to a slower clock, etc.
386:                */
387:           
388:           	UIESave = UIE;		//Save UIE values, only want to wake on certain events
0DD2  CF69     MOVFF UIE, UIESave
0DD4  F2B0     NOP
389:           	UIE = 0b00000100;	//Enabling the ACTVIF interrupt source only
0DD6  0E04     MOVLW 0x4
0DD8  6E69     MOVWF UIE, ACCESS
390:           						//Since ACTVIF triggers on any bus activity, it will also trigger on USB reset events.
391:           						//But that is okay, we want that.
392:           
393:               UIRbits.IDLEIF = 0;		//Clear interrupt flag, we are servicing the idle event
0DDA  9868     BCF UIR, 4, ACCESS
394:           
395:               UCONbits.SUSPND = 1;                    // Put USB module in power conserve
0DDC  826D     BSF UCON, 1, ACCESS
396:                                                       // mode, SIE clock inactive
397:           
398:           
399:           	//Configure I/O pins for lowest power.  This will be application specific.
400:           	#ifdef ENABLE_USB_LED_BLINK_STATUS
401:               	mLED_1_Off();
402:           	#endif
403:           
404:           	//Disable all microcontroller wake up sources, except for the one(s) which will
405:           	//be used to wake up the microcontroller.  At the very least, the USB activity
406:           	//detect interrupt should be enabled as a wake up source.
407:           	
408:               PIR2bits.USBIF = 0;		//Won't get clear if an enabled and pending wake up source was already triggered
0DDE  9AA1     BCF PIR2, 5, ACCESS
409:               						//However, since only the ACTVIF interrupt source is currently enabled,
410:               						//only bus activity events will prevent entry into sleep.
411:               						
412:               PIE2bits.USBIE = 1;     // Set USB wakeup source
0DE0  8AA0     BSF PIE2, 5, ACCESS
413:           
414:           	Sleep();				// Go to sleep, wake up when a USB activity event occurs
0DE2  0003     SLEEP
415:              	while((PIR2bits.USBIF == 0) && (RCONbits.TO == 0))		//If using the WDT, should go back to sleep if awoke by WDT instead of USBIF
0DE4  50A1     MOVF PIR2, W, ACCESS
0DE6  0B20     ANDLW 0x20
0DE8  E105     BNZ 0xDF4
0DEA  50D0     MOVF RCON, W, ACCESS
0DEC  0B08     ANDLW 0x8
0DEE  E102     BNZ 0xDF4
0DF2  D7F8     BRA 0xDE4
416:              	{
417:           	   	Sleep();				//Entry into sleep clears WDT count, much like executing ClrWdt() instruction	
0DF0  0003     SLEEP
418:           	}	
419:           
420:               PIE2bits.USBIE = 0;
0DF4  9AA0     BCF PIE2, 5, ACCESS
421:               UIE |= UIESave;		//Restore UIE to state it was in prior to entering USB suspend (with the ACTVIF enabled as well, used later in stack)
0DF6  0102     MOVLB 0x2
0DF8  51B0     MOVF 0xB0, W, BANKED
0DFA  1269     IORWF UIE, F, ACCESS
422:               					//USB suspend events do not by themselves cause any loss of 
423:               					//state information inside either the USB device firmware, or 
424:               					//in the USB host software.
425:           
426:           	//Now insert code to restore states of I/O pins if desired/if it was changed prior to entering sleep
427:           
428:           
429:           	//Note: If using the two-speed startup feature, wakeup and execution will occur before the main oscillator + PLL
430:           	//has had a chance to start.  Device will run from INTOSC (no PLL).  However, USB module cannot be clocked
431:           	//and receive correct USB data when it is not clocked with the correct frequency clock source.
432:           	//Therefore, when using two-speed startup, should execute software delay to prevent any other code
433:           	//(some of which may expect normal frequncy operation) from executing until the main oscillator is ready.
434:           	//The host will allow at least 10ms for USB resume recovery, during which it will not try to communicate
435:           	//with the device (other than SOFs, which will be ignored since UCONbits.SUSPND = 1)
436:           
437:           	//This code delays ~5ms @ 8MHz to execute (using C18 3.21 with full optimizations enabled), but takes much less time at 48MHz.
438:               uint_delay_counter = 725;
0DFC  0102     MOVLB 0x2
0DFE  0ED5     MOVLW 0xD5
0E00  6FB8     MOVWF 0xB8, BANKED
0E02  0E02     MOVLW 0x2
0E04  6FB9     MOVWF 0xB9, BANKED
439:               while(uint_delay_counter--)	//Device will switch clocks (if using two-speed startup) while executing this loop
0E06  0102     MOVLB 0x2
0E08  C2B8     MOVFF uint_delay_counter, __tmp_0
0E0A  F000     NOP
0E0C  C2B9     MOVFF 0x2B9, 0x1
0E0E  F001     NOP
0E10  07B8     DECF 0xB8, F, BANKED
0E12  0E00     MOVLW 0x0
0E14  5BB9     SUBWFB 0xB9, F, BANKED
0E16  5000     MOVF __tmp_0, W, ACCESS
0E18  1001     IORWF 0x1, W, ACCESS
0E1A  E002     BZ 0xE20
0E1E  D7F3     BRA 0xE06
440:               {
441:           	    ClrWdt();
0E1C  0004     CLRWDT
442:           	} 
443:           	//Primary oscillator and PLL should be running by now.
444:           
445:               /* End Modifiable Section */
446:           
447:           }//end USBSuspend
0E20  0012     RETURN 0
448:           
449:           /******************************************************************************
450:            * Function:        void USBWakeFromSuspend(void)
451:            *
452:            * PreCondition:    None
453:            *
454:            * Input:           None
455:            *
456:            * Output:          None
457:            *
458:            * Side Effects:    None
459:            *
460:            * Overview:
461:            *
462:            * Note:            None
463:            *****************************************************************************/
464:           void USBWakeFromSuspend(void)
465:           {
466:               /*
467:                * If using clock switching, this is the place to restore the
468:                * original clock frequency.
469:                */
470:               UCONbits.SUSPND = 0;
0E22  926D     BCF UCON, 1, ACCESS
471:               UIEbits.ACTVIE = 0;
0E24  9469     BCF UIE, 2, ACCESS
472:           
473:               /********************************************************************
474:               Bug Fix: August 14, 2007
475:               *********************************************************************
476:               The ACTVIF bit cannot be cleared immediately after the USB module wakes
477:               up from Suspend or while the USB module is suspended. A few clock cycles
478:               are required to synchronize the internal hardware state machine before
479:               the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
480:               before the internal hardware is synchronized may not have an effect on
481:               the value of ACTVIF. Additonally, if the USB module uses the clock from
482:               the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
483:               module may not be immediately operational while waiting for the 96 MHz
484:               PLL to lock.
485:               ********************************************************************/
486:               // UIRbits.ACTVIF = 0;                      // Removed
487:               while(UIRbits.ACTVIF){UIRbits.ACTVIF = 0;}  // Added
0E26  A468     BTFSS UIR, 2, ACCESS
0E28  D002     BRA 0xE2E
0E2A  9468     BCF UIR, 2, ACCESS
0E2C  D7FC     BRA 0xE26
488:           
489:           }//end USBWakeFromSuspend
0E2E  0012     RETURN 0
490:           
491:           //Commented out USBRemoteWakeup() function for HID bootloader use.  This feature
492:           //isn't very useful in a bootloader, and it takes extra code space.
493:           ///******************************************************************************
494:           // * Function:        void USBRemoteWakeup(void)
495:           // *
496:           // * PreCondition:    None
497:           // *
498:           // * Input:           None
499:           // *
500:           // * Output:          None
501:           // *
502:           // * Side Effects:    None
503:           // *
504:           // * Overview:        This function should be called by user when the device
505:           // *                  is waken up by an external stimulus other than ACTIVIF.
506:           // *                  Please read the note below to understand the limitations.
507:           // *
508:           // * Note:            The modifiable section in this routine should be changed
509:           // *                  to meet the application needs. Current implementation
510:           // *                  temporary blocks other functions from executing for a
511:           // *                  period of 1-13 ms depending on the core frequency.
512:           // *
513:           // *                  According to USB 2.0 specification section 7.1.7.7,
514:           // *                  "The remote wakeup device must hold the resume signaling
515:           // *                  for at lest 1 ms but for no more than 15 ms."
516:           // *                  The idea here is to use a delay counter loop, using a
517:           // *                  common value that would work over a wide range of core
518:           // *                  frequencies.
519:           // *                  That value selected is 1800. See table below:
520:           // *                  ==========================================================
521:           // *                  Core Freq(MHz)      MIP         RESUME Signal Period (ms)
522:           // *                  ==========================================================
523:           // *                      48              12          1.05
524:           // *                       4              1           12.6
525:           // *                  ==========================================================
526:           // *                  * These timing could be incorrect when using code
527:           // *                    optimization or extended instruction mode,
528:           // *                    or when having other interrupts enabled.
529:           // *                    Make sure to verify using the MPLAB SIM's Stopwatch
530:           // *****************************************************************************/
531:           //void USBRemoteWakeup(void)
532:           //{
533:           //    static word delay_count;
534:           //
535:           //    if(usb_stat.RemoteWakeup == 1)          // Check if RemoteWakeup function
536:           //    {                                       // has been enabled by the host.
537:           ///********************************************************************
538:           //Bug Fix: August 14, 2007
539:           //*********************************************************************
540:           //ACTVIF should be clear after exiting USBRemoteWakeup().
541:           //This was supposed to be done when calling USBWakeFromSuspend() from
542:           //USBRemoteWakeup(). However, this was not the case because when the
543:           //RESUME signal is sent, it causes the ACTVIF bit to set again.
544:           //By clearing the SUSPND bit only, it leaves the ACTVIE as one, and
545:           //when the RESUME signal is sent, it causes the ACTVIF to set.
546:           //Now both ACTVIE and ACTVIF are set, allowing the firmware to
547:           //properly see the event and call USBWakeFromSuspend() on the next
548:           //polling cycle of USBDriverService().
549:           //********************************************************************/
550:           //        /* Unsuspend USB module */
551:           //        //USBWakeFromSuspend();             // Removed
552:           //        UCONbits.SUSPND = 0;                // Added
553:           ///*******************************************************************/
554:           //
555:           //        UCONbits.RESUME = 1;                // Start RESUME signaling
556:           //
557:           //        /* Modifiable Section */
558:           //
559:           //        delay_count = 1800U;                // Set RESUME line for 1-13 ms
560:           //        do
561:           //        {
562:           //            delay_count--;
563:           //        }while(delay_count);
564:           //
565:           //        /* End Modifiable Section */
566:           //
567:           //        UCONbits.RESUME = 0;
568:           //    }//endif
569:           //}//end USBRemoteWakeup
570:           //
571:           /******************************************************************************
572:            * Function:        void USB_SOF_Handler(void)
573:            *
574:            * PreCondition:    None
575:            *
576:            * Input:           None
577:            *
578:            * Output:          None
579:            *
580:            * Side Effects:    None
581:            *
582:            * Overview:        The USB host sends out a SOF packet to full-speed devices
583:            *                  every 1 ms. This interrupt may be useful for isochronous
584:            *                  pipes. End designers should implement callback routine
585:            *                  as necessary.
586:            *
587:            * Note:            None
588:            *****************************************************************************/
589:           //void USB_SOF_Handler(void)
590:           //{
591:           //    /* Callback routine here */
592:           //
593:           //    UIRbits.SOFIF = 0;
594:           //}//end USB_SOF_Handler
595:           
596:           /******************************************************************************
597:            * Function:        void USBStallHandler(void)
598:            *
599:            * PreCondition:    A STALL packet is sent to the host by the SIE.
600:            *
601:            * Input:           None
602:            *
603:            * Output:          None
604:            *
605:            * Side Effects:    None
606:            *
607:            * Overview:        The STALLIF is set anytime the SIE sends out a STALL
608:            *                  packet regardless of which endpoint causes it.
609:            *                  A Setup transaction overrides the STALL function. A stalled
610:            *                  endpoint stops stalling once it receives a setup packet.
611:            *                  In this case, the SIE will accepts the Setup packet and
612:            *                  set the TRNIF flag to notify the firmware. STALL function
613:            *                  for that particular endpoint pipe will be automatically
614:            *                  disabled (direction specific).
615:            *
616:            *                  There are a few reasons for an endpoint to be stalled.
617:            *                  1. When a non-supported USB request is received.
618:            *                     Example: GET_DESCRIPTOR(DEVICE_QUALIFIER)
619:            *                  2. When an endpoint is currently halted.
620:            *                  3. When the device class specifies that an endpoint must
621:            *                     stall in response to a specific event.
622:            *                     Example: Mass Storage Device Class
623:            *                              If the CBW is not valid, the device shall
624:            *                              STALL the Bulk-In pipe.
625:            *                              See USB Mass Storage Class Bulk-only Transport
626:            *                              Specification for more details.
627:            *
628:            * Note:            UEPn.EPSTALL can be scanned to see which endpoint causes
629:            *                  the stall event.
630:            *****************************************************************************/
631:           void USBStallHandler(void)
632:           {
633:               /*
634:                * Does not really have to do anything here,
635:                * even for the control endpoint.
636:                * All BDs of Endpoint 0 are owned by SIE right now,
637:                * but once a Setup Transaction is received, the ownership
638:                * for EP0_OUT will be returned to CPU.
639:                * When the Setup Transaction is serviced, the ownership
640:                * for EP0_IN will then be forced back to CPU by firmware.
641:                */
642:               if(UEP0bits.EPSTALL == 1)
0E30  A070     BTFSS UEP0, 0, ACCESS
0E32  D00C     BRA 0xE4C
643:               {
644:                   /********************************************************************
645:                   Bug Fix: August 14, 2007 (#F4)
646:                   *********************************************************************
647:                   In a control transfer, when a request is not supported, all
648:                   subsequent transactions should be stalled until a new SETUP
649:                   transaction is received. The original firmware only stalls the
650:                   first subsequent transaction, then ACKs others. Typically, a
651:                   compliance USB host will stop sending subsequent transactions
652:                   once the first stall is received. In the original firmware,
653:                   function USBStallHandler() in usbdrv.c calls
654:                   USBPrepareForNextSetupTrf() when a STALL event occurred on EP0.
655:                   In turn, USBPrepareForNextSetupTrf() reconfigures EP0 IN and OUT
656:                   to prepare for the next SETUP transaction. The work around is not
657:                   to call USBPrepareForNextSetupTrf() in USBStallHandler().
658:                   ********************************************************************/
659:                   //USBPrepareForNextSetupTrf();      // Removed
660:                   /*******************************************************************/
661:                   
662:                   /********************************************************************
663:                   Bug Fix: August 14, 2007 (#F7 - Partial 4/4)
664:                   *********************************************************************
665:                   For a control transfer read, if the host tries to read more data
666:                   than what it has requested, the peripheral device should stall the
667:                   extra IN transactions and the status stage. Typically, a host does
668:                   not try to read more data than what it has requested. The original
669:                   firmware did not handle this situation. Instead of stalling extra
670:                   IN transactions, the device kept sending out zero length packets.
671:                   
672:                   This work around checks to make sure that at least one extra IN
673:                   transaction is stalled before setting the OUT endpoint to stall the
674:                   status stage.
675:                   ********************************************************************/
676:                   if((ep0Bo.Stat._byte == _USIE) && (ep0Bi.Stat._byte == (_USIE|_BSTALL)))
0E34  0E80     MOVLW 0x80
0E36  0104     MOVLB 0x4
0E38  5D00     SUBWF __tmp_0, W, BANKED
0E3A  E107     BNZ 0xE4A
0E3C  0E84     MOVLW 0x84
0E3E  0104     MOVLB 0x4
0E40  5D04     SUBWF 0x4, W, BANKED
0E42  E103     BNZ 0xE4A
677:                   {
678:                       // Set ep0Bo to stall also
679:                       ep0Bo.Stat._byte = _USIE|_DAT0|_DTSEN|_BSTALL;
0E44  0104     MOVLB 0x4
0E46  0E8C     MOVLW 0x8C
0E48  6F00     MOVWF __tmp_0, BANKED
680:                   }//end if
681:                   /*******************************************************************/
682:           
683:                   UEP0bits.EPSTALL = 0;         	    // Clear STALL status
0E4A  9070     BCF UEP0, 0, ACCESS
684:               }
685:               UIRbits.STALLIF = 0;
0E4C  9A68     BCF UIR, 5, ACCESS
686:           }//end USBStallHandler
0E4E  0012     RETURN 0
687:           
688:           /******************************************************************************
689:            * Function:        void USBErrorHandler(void)
690:            *
691:            * PreCondition:    None
692:            *
693:            * Input:           None
694:            *
695:            * Output:          None
696:            *
697:            * Side Effects:    None
698:            *
699:            * Overview:        The purpose of this interrupt is mainly for debugging
700:            *                  during development. Check UEIR to see which error causes
701:            *                  the interrupt.
702:            *
703:            * Note:            None
704:            *****************************************************************************/
705:           //void USBErrorHandler(void)
706:           //{
707:           //    /* Callback routine here */
708:           //
709:           ///********************************************************************
710:           //Bug Fix: August 14, 2007
711:           //*********************************************************************
712:           //UERRIF bit is a read-only bit and cannot be cleared directly.
713:           //The correct way is to clear UEIR register.
714:           //********************************************************************/
715:           //    //UIRbits.UERRIF = 0;           // Removed
716:           //     UEIR = 0;                      // Added
717:           //}//end USBErrorHandler
718:           
719:           /******************************************************************************
720:            * Function:        void USBProtocolResetHandler(void)
721:            *
722:            * PreCondition:    A USB bus reset is received from the host.
723:            *
724:            * Input:           None
725:            *
726:            * Output:          None
727:            *
728:            * Side Effects:    Currently, this routine flushes any pending USB
729:            *                  transactions. It empties out the USTAT FIFO. This action
730:            *                  might not be desirable in some applications.
731:            *
732:            * Overview:        Once a USB bus reset is received from the host, this
733:            *                  routine should be called. It resets the device address to
734:            *                  zero, disables all non-EP0 endpoints, initializes EP0 to
735:            *                  be ready for default communication, clears all USB
736:            *                  interrupt flags, unmasks applicable USB interrupts, and
737:            *                  reinitializes internal state-machine variables.
738:            *
739:            * Note:            None
740:            *****************************************************************************/
741:           void USBProtocolResetHandler(void)
742:           {
743:               UEIR = 0;                       // Clear all USB error flags
0E50  6A6A     CLRF UEIR, ACCESS
744:               UIR = 0;                        // Clears all USB interrupts
0E52  6A68     CLRF UIR, ACCESS
745:               UEIE = 0b10011111;              // Unmask all USB error interrupts
0E54  0E9F     MOVLW 0x9F
0E56  6E6B     MOVWF UEIE, ACCESS
746:               UIE = 0b01111011;               // Enable all interrupts except ACTVIE
0E58  0E7B     MOVLW 0x7B
0E5A  6E69     MOVWF UIE, ACCESS
747:           
748:               UADDR = 0x00;                   // Reset to default address
0E5C  6A6E     CLRF UADDR, ACCESS
749:               mDisableEP1to7();              // Reset all non-EP0 UEPn registers
0E5E  6A71     CLRF UEP1, ACCESS
0E60  6A72     CLRF UEP2, ACCESS
0E62  6A73     CLRF UEP3, ACCESS
0E64  6A74     CLRF UEP4, ACCESS
0E66  6A75     CLRF UEP5, ACCESS
0E68  6A76     CLRF UEP6, ACCESS
0E6A  6A77     CLRF UEP7, ACCESS
750:               UEP0 = EP_CTRL|HSHK_EN;         // Init EP0 as a Ctrl EP, see usbdrv.h
0E6C  0E16     MOVLW 0x16
0E6E  6E70     MOVWF UEP0, ACCESS
751:           
752:               while(UIRbits.TRNIF == 1)       // Flush any pending transactions
0E70  A668     BTFSS UIR, 3, ACCESS
0E72  D004     BRA 0xE7C
0E7A  D7FA     BRA 0xE70
753:               {
754:                   UIRbits.TRNIF = 0;
0E74  9668     BCF UIR, 3, ACCESS
755:           		ClearWatchdog();    //5 Tcy minimum (2 for call, 2 for return, 1 for clearing) to allow TRNIF to (potentially) reassert
0E76  EC31     CALL 0x662, 0
0E78  F003     NOP
756:               }
757:           
758:               UCONbits.PKTDIS = 0;            // Make sure packet processing is enabled
0E7C  986D     BCF UCON, 4, ACCESS
759:               USBPrepareForNextSetupTrf();    // Declared in usbctrltrf.c
0E7E  EC85     CALL 0x90A, 0
0E80  F004     NOP
760:               //Prepare EP0 OUT to receive the first SETUP packet
761:               ep0Bo.Cnt = EP0_BUFF_SIZE;
0E82  0104     MOVLB 0x4
0E84  0E08     MOVLW 0x8
0E86  6F01     MOVWF 0x1, BANKED
762:               ep0Bo.ADR = (byte*)(&SetupPkt);
0E88  0E10     MOVLW 0x10
0E8A  6F02     MOVWF 0x2, BANKED
0E8C  0E04     MOVLW 0x4
0E8E  6F03     MOVWF 0x3, BANKED
763:               ep0Bo.Stat._byte = _USIE|_DAT0|_DTSEN|_BSTALL;	
0E90  0E8C     MOVLW 0x8C
0E92  6F00     MOVWF __tmp_0, BANKED
764:               
765:               usb_stat.RemoteWakeup = 0;      // Default status flag to disable
0E94  0102     MOVLB 0x2
0E96  91B5     BCF 0xB5, 0, BANKED
766:               usb_active_cfg = 0;             // Clear active configuration
0E98  0102     MOVLB 0x2
0E9A  6BB6     CLRF 0xB6, BANKED
767:               usb_device_state = DEFAULT_STATE;
0E9C  0102     MOVLB 0x2
0E9E  0E03     MOVLW 0x3
0EA0  6FB4     MOVWF 0xB4, BANKED
768:           }//end USBProtocolResetHandler
0EA2  0012     RETURN 0
769:           
770:           
771:           /* Auxiliary Function */
772:           void ClearArray(byte* startAdr,byte count)
773:           {
774:               *startAdr;
0EA4  C2B1     MOVFF startAdr, FSR0L
0EA6  FFE9     NOP
0EA8  C2B2     MOVFF 0x2B2, FSR0H
0EAA  FFEA     NOP
775:               while(count)
0EAC  0102     MOVLB 0x2
0EAE  51B3     MOVF 0xB3, W, BANKED
0EB0  E004     BZ 0xEBA
0EB8  D7F9     BRA 0xEAC
776:               {
777:                   _asm
778:                   clrf POSTINC0,0
0EB2  6AEE     CLRF POSTINC0, ACCESS
779:                   _endasm
780:                   count--;
0EB4  0102     MOVLB 0x2
0EB6  07B3     DECF 0xB3, F, BANKED
781:               }//end while
782:           }//end ClearArray
0EBA  0012     RETURN 0
783:           
784:           /** EOF usbdrv.c *************************************************************/
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/usbctrltrf.c  ------------------------------------------
1:             /*********************************************************************
2:              *
3:              *                Microchip USB C18 Firmware Version 1.3a
4:              *
5:              *********************************************************************
6:              * FileName:        usbctrltrf.c
7:              * Dependencies:    See INCLUDES section below
8:              * Processor:       PIC18
9:              * Compiler:        C18 3.11+
10:             * Company:         Microchip Technology, Inc.
11:             *
12:             * Software License Agreement
13:             *
14:             * The software supplied herewith by Microchip Technology Incorporated
15:             * (the ?Company?) for its PICmicro Microcontroller is intended and
16:             * supplied to you, the Company?s customer, for use solely and
17:             * exclusively on Microchip PICmicro Microcontroller products. The
18:             * software is owned by the Company and/or its supplier, and is
19:             * protected under applicable copyright laws. All rights are reserved.
20:             * Any use in violation of the foregoing restrictions may subject the
21:             * user to criminal sanctions under applicable laws, as well as to
22:             * civil liability for the breach of the terms and conditions of this
23:             * license.
24:             *
25:             * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
26:             * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:             * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:             * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:             * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:             *
32:             * Author               Date        Comment
33:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
34:             * Rawin Rojvanit       11/19/04    Original.
35:             * Rawin Rojvanit       05/14/07    Bug fixes.
36:             * Fritz Schlunder		04/14/09	Improved SETUP response for hosts
37:             *									with aggressive control transfer
38:             *									timing.
39:             ********************************************************************/
40:            
41:            /** I N C L U D E S **********************************************************/
42:            #include <p18cxxx.h>
43:            #include "typedefs.h"
44:            #include "usb.h"
45:            
46:            /** V A R I A B L E S ********************************************************/
47:            #pragma udata
48:            byte ctrl_trf_state;                // Control Transfer State
49:            byte ctrl_trf_session_owner;        // Current transfer session owner
50:            
51:            POINTER pSrc;                       // Data source pointer
52:            POINTER pDst;                       // Data destination pointer
53:            WORD wCount;                        // Data counter
54:            
55:            /********************************************************************
56:            Bug Fix: May 14, 2007 (#F7)
57:            *********************************************************************
58:            For a control transfer read, if the host tries to read more data
59:            than what it has requested, the peripheral device should stall the
60:            extra IN transactions and the status stage. Typically, a host does
61:            not try to read more data than what it has requested. The original
62:            firmware did not handle this situation. Instead of stalling extra
63:            IN transactions, the device kept sending out zero length packets.
64:            
65:            The new variable introduced is used to keep track if a short IN
66:            packet has been sent or not. From this the state machine can
67:            decide if it should stall future extra IN transactions or not.
68:            ********************************************************************/
69:            byte short_pkt_status;              // Flag used by Control Transfer Read
70:            
71:            /** P R I V A T E  P R O T O T Y P E S ***************************************/
72:            void USBCtrlTrfSetupHandler(void);
73:            void USBCtrlTrfOutHandler(void);
74:            void USBCtrlTrfInHandler(void);
75:            
76:            /** D E C L A R A T I O N S **************************************************/
77:            #pragma code
78:            /******************************************************************************
79:             * Function:        void USBCtrlEPService(void)
80:             *
81:             * PreCondition:    USTAT is loaded with a valid endpoint address.
82:             *
83:             * Input:           None
84:             *
85:             * Output:          None
86:             *
87:             * Side Effects:    None
88:             *
89:             * Overview:        USBCtrlEPService checks for three transaction types that
90:             *                  it knows how to service and services them:
91:             *                  1. EP0 SETUP
92:             *                  2. EP0 OUT
93:             *                  3. EP0 IN
94:             *                  It ignores all other types (i.e. EP1, EP2, etc.)
95:             *
96:             * Note:            None
97:             *****************************************************************************/
98:            /********************************************************************
99:            Bug Fix: May 14, 2007
100:           ********************************************************************/
101:           byte USBCtrlEPService(void)
102:           {
103:               if(USTAT == EP00_OUT)
0690  506C     MOVF USTAT, W, ACCESS
0692  E133     BNZ 0x6FA
104:               {
105:                   UIRbits.TRNIF = 0;
0694  9668     BCF UIR, 3, ACCESS
106:           
107:           		//If the current EP0 OUT buffer has a SETUP packet
108:                   if(ep0Bo.Stat.PID == SETUP_TOKEN)
0696  0104     MOVLB 0x4
0698  5100     MOVF __tmp_0, W, BANKED
069A  0B3C     ANDLW 0x3C
069C  42E8     RRNCF WREG, F, ACCESS
069E  42E8     RRNCF WREG, F, ACCESS
06A0  080D     SUBLW 0xD
06A2  E129     BNZ 0x6F6
109:                   {
110:           	        //Check if the SETUP transaction data went into the CtrlTrfData buffer.
111:           	        //If so, need to copy it to the SetupPkt buffer so that it can be 
112:           	        //processed correctly by USBCtrlTrfSetupHandler().
113:           	        if(ep0Bo.ADR == (byte*)(&CtrlTrfData))	
06A4  0E18     MOVLW 0x18
06A6  1902     XORWF 0x2, W, BANKED
06A8  E124     BNZ 0x6F2
06AA  0E04     MOVLW 0x4
06AC  1903     XORWF 0x3, W, BANKED
06AE  E121     BNZ 0x6F2
114:           	        {
115:           		        unsigned char setup_cnt;
116:           		
117:           		        ep0Bo.ADR = (byte*)(&SetupPkt);
06B0  0E10     MOVLW 0x10
06B2  6F02     MOVWF 0x2, BANKED
06B4  0E04     MOVLW 0x4
06B6  6F03     MOVWF 0x3, BANKED
118:           		        for(setup_cnt = 0; setup_cnt < sizeof(CTRL_TRF_SETUP); setup_cnt++)
06B8  0102     MOVLB 0x2
06BA  6BA9     CLRF 0xA9, BANKED
06BC  51A9     MOVF 0xA9, W, BANKED
06BE  6E00     MOVWF __tmp_0, ACCESS
06C0  6A01     CLRF 0x1, ACCESS
06C2  0E08     MOVLW 0x8
06C4  5C00     SUBWF __tmp_0, W, ACCESS
06C6  0E00     MOVLW 0x0
06C8  5801     SUBWFB 0x1, W, ACCESS
06CA  E213     BC 0x6F2
06EE  2BA9     INCF 0xA9, F, BANKED
06F0  D7E5     BRA 0x6BC
119:           		        {
120:           		            *(((byte*)&SetupPkt)+setup_cnt) = *(((byte*)&CtrlTrfData)+setup_cnt);
06CC  51A9     MOVF 0xA9, W, BANKED
06CE  6AEA     CLRF FSR0H, ACCESS
06D0  0F18     ADDLW 0x18
06D2  6EE9     MOVWF FSR0L, ACCESS
06D4  0E04     MOVLW 0x4
06D6  22EA     ADDWFC FSR0H, F, ACCESS
06D8  50EF     MOVF INDF0, W, ACCESS
06DA  6EE6     MOVWF POSTINC1, ACCESS
06DC  51A9     MOVF 0xA9, W, BANKED
06DE  6AEA     CLRF FSR0H, ACCESS
06E0  0F10     ADDLW 0x10
06E2  6EE9     MOVWF FSR0L, ACCESS
06E4  0E04     MOVLW 0x4
06E6  22EA     ADDWFC FSR0H, F, ACCESS
06E8  52E5     MOVF POSTDEC1, F, ACCESS
06EA  50E7     MOVF INDF1, W, ACCESS
06EC  6EEF     MOVWF INDF0, ACCESS
121:           		        }//end for
122:           		    } 
123:           	        
124:           			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
125:                       USBCtrlTrfSetupHandler();
06F2  D80A     RCALL USBCtrlTrfSetupHandler
126:                   }
127:                   else
06F4  0C01     RETLW 0x1
128:                   {
129:           			//Handle the DATA transfer
130:                       USBCtrlTrfOutHandler();
06F6  D83A     RCALL USBCtrlTrfOutHandler
131:                   }
132:           
133:           
134:               }
135:               else if(USTAT == EP00_IN)            	        // EP0 IN
06F8  0C01     RETLW 0x1
06FA  0E04     MOVLW 0x4
06FC  5C6C     SUBWF USTAT, W, ACCESS
06FE  E103     BNZ 0x706
136:               {
137:                   UIRbits.TRNIF = 0;
0700  9668     BCF UIR, 3, ACCESS
138:                   USBCtrlTrfInHandler();
0702  D84B     RCALL USBCtrlTrfInHandler
139:               }
140:               else
0704  0C01     RETLW 0x1
141:               {
142:                   return 0;           // Return '0', if not an EP0 transaction
0706  0C00     RETLW 0x0
143:               }
144:               return 1;               // Return '1', if TRNIF has been cleared
145:           
146:           }//end USBCtrlEPService
147:           
148:           /******************************************************************************
149:            * Function:        void USBCtrlTrfSetupHandler(void)
150:            *
151:            * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
152:            *
153:            * Input:           None
154:            *
155:            * Output:          None
156:            *
157:            * Side Effects:    None
158:            *
159:            * Overview:        This routine is a task dispatcher and has 3 stages.
160:            *                  1. It initializes the control transfer state machine.
161:            *                  2. It calls on each of the module that may know how to
162:            *                     service the Setup Request from the host.
163:            *                     Module Example: USB9, HID, CDC, MSD, ...
164:            *                     As new classes are added, ClassReqHandler table in
165:            *                     usbdsc.c should be updated to call all available
166:            *                     class handlers.
167:            *                  3. Once each of the modules has had a chance to check if
168:            *                     it is responsible for servicing the request, stage 3
169:            *                     then checks direction of the transfer to determine how
170:            *                     to prepare EP0 for the control transfer.
171:            *                     Refer to USBCtrlEPServiceComplete() for more details.
172:            *
173:            * Note:            Microchip USB Firmware has three different states for
174:            *                  the control transfer state machine:
175:            *                  1. WAIT_SETUP
176:            *                  2. CTRL_TRF_TX
177:            *                  3. CTRL_TRF_RX
178:            *                  Refer to firmware manual to find out how one state
179:            *                  is transitioned to another.
180:            *
181:            *                  A Control Transfer is composed of many USB transactions.
182:            *                  When transferring data over multiple transactions,
183:            *                  it is important to keep track of data source, data
184:            *                  destination, and data count. These three parameters are
185:            *                  stored in pSrc,pDst, and wCount. A flag is used to
186:            *                  note if the data source is from ROM or RAM.
187:            *
188:            *****************************************************************************/
189:           void USBCtrlTrfSetupHandler(void)
190:           {
191:               byte i;
192:           
193:               /********************************************************************
194:               Bug Fix: May 14, 2007 (#F7 - Partial 1/4)
195:               *********************************************************************
196:               For a control transfer read, if the host tries to read more data
197:               than what it has requested, the peripheral device should stall the
198:               extra IN transactions and the status stage. Typically, a host does
199:               not try to read more data than what it has requested. The original
200:               firmware did not handle this situation. Instead of stalling extra
201:               IN transactions, the device kept sending out zero length packets.
202:               
203:               This work around forces the IN endpoint back to be owned by the
204:               CPU after if it was stalled previously. The short_pkt_status flag
205:               is also re-initialized.
206:               ********************************************************************/
207:               if(ep0Bi.Stat.UOWN != 0)
0708  0104     MOVLB 0x4
070A  BF04     BTFSC 0x4, 7, BANKED
208:                   ep0Bi.Stat._byte = _UCPU;           // Compensate for after a STALL
070C  6B04     CLRF 0x4, BANKED
209:               short_pkt_status = SHORT_PKT_NOT_USED;
070E  0102     MOVLB 0x2
0710  6BA8     CLRF 0xA8, BANKED
210:               /*******************************************************************/
211:           
212:               /* Stage 1 */
213:               ctrl_trf_state = WAIT_SETUP;
0712  6BA0     CLRF 0xA0, BANKED
214:               ctrl_trf_session_owner = MUID_NULL;     // Set owner to NULL
0714  6BA1     CLRF PacketFromPC, BANKED
215:               wCount._word = 0;
0716  6BA6     CLRF 0xA6, BANKED
0718  6BA7     CLRF 0xA7, BANKED
216:           
217:               /* Stage 2 */
218:               USBCheckStdRequest();                   // See system\usb9\usb9.c
071A  ECA4     CALL 0x948, 0
071C  F004     NOP
219:           
220:               for(i=0;i < (sizeof(ClassReqHandler)/sizeof(pFunc));i++)
071E  0102     MOVLB 0x2
0720  6BAA     CLRF 0xAA, BANKED
0722  51AA     MOVF 0xAA, W, BANKED
0724  6E00     MOVWF __tmp_0, ACCESS
0726  6A01     CLRF 0x1, ACCESS
0728  0E01     MOVLW 0x1
072A  5C00     SUBWF __tmp_0, W, ACCESS
072C  0E00     MOVLW 0x0
072E  5801     SUBWFB 0x1, W, ACCESS
0730  E21B     BC 0x768
0762  0102     MOVLB 0x2
0764  2BAA     INCF 0xAA, F, BANKED
0766  D7DD     BRA 0x722
221:               {
222:                   if(ctrl_trf_session_owner != MUID_NULL)break;
0732  51A1     MOVF PacketFromPC, W, BANKED
0734  E119     BNZ 0x768
223:                   ClassReqHandler[i]();               // See autofiles\usbdsc.c
0736  51AA     MOVF 0xAA, W, BANKED
0738  6EF6     MOVWF TBLPTRL, ACCESS
073A  6AF7     CLRF TBLPTRH, ACCESS
073C  90D8     BCF STATUS, 0, ACCESS
073E  36F6     RLCF TBLPTRL, F, ACCESS
0740  36F7     RLCF TBLPTRH, F, ACCESS
0742  0E7C     MOVLW 0x7C
0744  26F6     ADDWF TBLPTRL, F, ACCESS
0746  0E0F     MOVLW 0xF
0748  22F7     ADDWFC TBLPTRH, F, ACCESS
074A  0009     TBLRD*+
074C  CFF5     MOVFF TABLAT, __tmp_0
074E  F000     NOP
0750  0008     TBLRD*
0752  CFF5     MOVFF TABLAT, 0x1
0754  F001     NOP
0756  D004     BRA 0x760
0758  C001     MOVFF 0x1, PCLATH
075A  FFFA     NOP
075C  5000     MOVF __tmp_0, W, ACCESS
075E  6EF9     MOVWF PCL, ACCESS
0760  DFFB     RCALL 0x758
224:               }//end while
225:           
226:               /* Stage 3 */
227:               USBCtrlEPServiceComplete();
0768  EF4C     GOTO 0x898
076A  F004     NOP
228:           
229:           }//end USBCtrlTrfSetupHandler
230:           
231:           /******************************************************************************
232:            * Function:        void USBCtrlTrfOutHandler(void)
233:            *
234:            * PreCondition:    None
235:            *
236:            * Input:           None
237:            *
238:            * Output:          None
239:            *
240:            * Side Effects:    None
241:            *
242:            * Overview:        This routine handles an OUT transaction according to
243:            *                  which control transfer state is currently active.
244:            *
245:            * Note:            Note that if the the control transfer was from
246:            *                  host to device, the session owner should be notified
247:            *                  at the end of each OUT transaction to service the
248:            *                  received data.
249:            *
250:            *****************************************************************************/
251:           void USBCtrlTrfOutHandler(void)
252:           {
253:               if(ctrl_trf_state == CTRL_TRF_RX)
076C  0E02     MOVLW 0x2
076E  0102     MOVLB 0x2
0770  5DA0     SUBWF 0xA0, W, BANKED
0772  E10E     BNZ 0x790
254:               {
255:                   USBCtrlTrfRxService();
0774  D878     RCALL USBCtrlTrfRxService
256:           
257:                   /*
258:                    * Don't have to worry about overwriting _KEEP bit
259:                    * because if _KEEP was set, TRNIF would not have been
260:                    * generated in the first place.
261:                    */
262:           		ep0Bo.ADR = (byte*)(&CtrlTrfData);
0776  0104     MOVLB 0x4
0778  0E18     MOVLW 0x18
077A  6F02     MOVWF 0x2, BANKED
077C  0E04     MOVLW 0x4
077E  6F03     MOVWF 0x3, BANKED
263:           		ep0Bo.Cnt = EP0_BUFF_SIZE;
0780  0E08     MOVLW 0x8
0782  6F01     MOVWF 0x1, BANKED
264:                   if(ep0Bo.Stat.DTS == 0)
0784  BD00     BTFSC __tmp_0, 6, BANKED
0786  D002     BRA 0x78C
265:                       ep0Bo.Stat._byte = _USIE|_DAT1|_DTSEN;
0788  0EC8     MOVLW 0xC8
266:                   else
078A  D005     BRA 0x796
267:                       ep0Bo.Stat._byte = _USIE|_DAT0|_DTSEN;
078C  0E88     MOVLW 0x88
268:               }
269:               else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX
078E  D003     BRA 0x796
270:               {
271:           	    //Prepare EP0 OUT for the next SETUP transaction.
272:           		USBPrepareForNextSetupTrf();
0790  D8BC     RCALL USBPrepareForNextSetupTrf
273:                   ep0Bo.Cnt = EP0_BUFF_SIZE;
0792  D8CB     RCALL __pa_1
274:                   ep0Bo.ADR = (byte*)(&SetupPkt);
275:                   ep0Bo.Stat._byte = _USIE|_DAT0|_DTSEN|_BSTALL;			
0794  0E8C     MOVLW 0x8C
0796  6F00     MOVWF __tmp_0, BANKED
276:               }
277:           
278:           
279:           
280:           }//end USBCtrlTrfOutHandler
0798  0012     RETURN 0
281:           
282:           /******************************************************************************
283:            * Function:        void USBCtrlTrfInHandler(void)
284:            *
285:            * PreCondition:    None
286:            *
287:            * Input:           None
288:            *
289:            * Output:          None
290:            *
291:            * Side Effects:    None
292:            *
293:            * Overview:        This routine handles an IN transaction according to
294:            *                  which control transfer state is currently active.
295:            *
296:            *
297:            * Note:            A Set Address Request must not change the acutal address
298:            *                  of the device until the completion of the control
299:            *                  transfer. The end of the control transfer for Set Address
300:            *                  Request is an IN transaction. Therefore it is necessary
301:            *                  to service this unique situation when the condition is
302:            *                  right. Macro mUSBCheckAdrPendingState is defined in
303:            *                  usb9.h and its function is to specifically service this
304:            *                  event.
305:            *****************************************************************************/
306:           void USBCtrlTrfInHandler(void)
307:           {
308:               mUSBCheckAdrPendingState();         // Must check if in ADR_PENDING_STATE
079A  0E04     MOVLW 0x4
079C  0102     MOVLB 0x2
079E  5DB4     SUBWF 0xB4, W, BANKED
07A0  E109     BNZ 0x7B4
07A2  C412     MOVFF 0x412, UADDR
07A4  FF6E     NOP
07A6  506E     MOVF UADDR, W, ACCESS
07A8  0800     SUBLW 0x0
07AA  E202     BC 0x7B0
07AC  0E05     MOVLW 0x5
07AE  D001     BRA 0x7B2
07B0  0E03     MOVLW 0x3
07B2  6FB4     MOVWF 0xB4, BANKED
309:           
310:               if(ctrl_trf_state == CTRL_TRF_TX)
07B4  0102     MOVLB 0x2
07B6  05A0     DECF 0xA0, W, BANKED
07B8  E110     BNZ 0x7DA
311:               {
312:                   USBCtrlTrfTxService();
07BA  D811     RCALL USBCtrlTrfTxService
313:           
314:                   /********************************************************************
315:                   Bug Fix: May 14, 2007 (#F7 - Partial 2/4)
316:                   *********************************************************************
317:                   For a control transfer read, if the host tries to read more data
318:                   than what it has requested, the peripheral device should stall the
319:                   extra IN transactions and the status stage. Typically, a host does
320:                   not try to read more data than what it has requested. The original
321:                   firmware did not handle this situation. Instead of stalling extra
322:                   IN transactions, the device kept sending out zero length packets.
323:                   
324:                   This work around checks if a short IN packet has been sent or not.
325:                   If it has, the IN endpoint will be set to install the next IN token.
326:                   If not, then the original endpoint setup code will be executed.
327:                   ********************************************************************/
328:                   if(short_pkt_status == SHORT_PKT_SENT)
07BC  0E02     MOVLW 0x2
07BE  0102     MOVLB 0x2
07C0  5DA8     SUBWF 0xA8, W, BANKED
07C2  E103     BNZ 0x7CA
329:                   {
330:                       // If a short packet has been sent, don't want to send any more,
331:                       // stall next time if host is still trying to read.
332:                       ep0Bi.Stat._byte = _USIE|_BSTALL;
07C4  0104     MOVLB 0x4
07C6  0E84     MOVLW 0x84
333:                   }
334:                   /*******************************************************************/
335:                   else
07C8  D006     BRA 0x7D6
336:                   {
337:                       if(ep0Bi.Stat.DTS == 0)
07CA  0104     MOVLB 0x4
07CC  BD04     BTFSC 0x4, 6, BANKED
07CE  D002     BRA 0x7D4
338:                           ep0Bi.Stat._byte = _USIE|_DAT1|_DTSEN;
07D0  0EC8     MOVLW 0xC8
339:                       else
07D2  D001     BRA 0x7D6
340:                           ep0Bi.Stat._byte = _USIE|_DAT0|_DTSEN;
07D4  0E88     MOVLW 0x88
07D6  6F04     MOVWF 0x4, BANKED
341:                   }//end if(...)else
342:               }
343:               else // CTRL_TRF_RX
07D8  0012     RETURN 0
344:                   USBPrepareForNextSetupTrf();
07DA  EF85     GOTO 0x90A
07DC  F004     NOP
345:           
346:           }//end USBCtrlTrfInHandler
347:           
348:           /******************************************************************************
349:            * Function:        void USBCtrlTrfTxService(void)
350:            *
351:            * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
352:            *
353:            * Input:           None
354:            *
355:            * Output:          None
356:            *
357:            * Side Effects:    None
358:            *
359:            * Overview:        This routine should be called from only two places.
360:            *                  One from USBCtrlEPServiceComplete() and one from
361:            *                  USBCtrlTrfInHandler(). It takes care of managing a
362:            *                  transfer over multiple USB transactions.
363:            *
364:            * Note:            This routine works with isochronous endpoint larger than
365:            *                  256 bytes and is shown here as an example of how to deal
366:            *                  with BC9 and BC8. In reality, a control endpoint can never
367:            *                  be larger than 64 bytes.
368:            *****************************************************************************/
369:           void USBCtrlTrfTxService(void)
370:           {
371:               WORD byte_to_send;
372:           
373:               /*
374:                * First, have to figure out how many byte of data to send.
375:                */
376:               if(wCount._word < EP0_BUFF_SIZE)
07DE  0102     MOVLB 0x2
07E0  0E08     MOVLW 0x8
07E2  5DA6     SUBWF 0xA6, W, BANKED
07E4  0E00     MOVLW 0x0
07E6  59A7     SUBWFB 0xA7, W, BANKED
07E8  E20D     BC 0x804
377:               {
378:                   byte_to_send._word = wCount._word;
07EA  C2A6     MOVFF wCount, byte_to_send
07EC  F2AB     NOP
07EE  C2A7     MOVFF 0x2A7, 0x2AC
07F0  F2AC     NOP
379:           
380:                   /********************************************************************
381:                   Bug Fix: May 14, 2007 (#F7 - Partial 3/4)
382:                   *********************************************************************
383:                   For a control transfer read, if the host tries to read more data
384:                   than what it has requested, the peripheral device should stall the
385:                   extra IN transactions and the status stage. Typically, a host does
386:                   not try to read more data than what it has requested. The original
387:                   firmware did not handle this situation. Instead of stalling extra
388:                   IN transactions, the device kept sending out zero length packets.
389:                   
390:                   This work around updates the short_pkt_status flag to indicate
391:                   if a short packet has been sent or not.
392:                   ********************************************************************/
393:                   if(short_pkt_status == SHORT_PKT_NOT_USED)
07F2  51A8     MOVF 0xA8, W, BANKED
07F4  E102     BNZ 0x7FA
394:                   {
395:                       short_pkt_status = SHORT_PKT_PENDING;
07F6  0E01     MOVLW 0x1
396:                   }
397:                   else if(short_pkt_status == SHORT_PKT_PENDING)
07F8  D003     BRA 0x800
07FA  05A8     DECF 0xA8, W, BANKED
07FC  E106     BNZ 0x80A
398:                   {
399:                       short_pkt_status = SHORT_PKT_SENT;
07FE  0E02     MOVLW 0x2
0800  6FA8     MOVWF 0xA8, BANKED
400:                   }//end if
401:                   /*******************************************************************/
402:               }
403:               else
0802  D003     BRA 0x80A
404:                   byte_to_send._word = EP0_BUFF_SIZE;
0804  0E08     MOVLW 0x8
0806  6FAB     MOVWF 0xAB, BANKED
0808  6BAC     CLRF 0xAC, BANKED
405:           
406:               /*
407:                * Next, load the number of bytes to send to BC9..0 in buffer descriptor
408:                */
409:               ep0Bi.Stat.BC9 = 0;
080A  0104     MOVLB 0x4
080C  9304     BCF 0x4, 1, BANKED
410:               ep0Bi.Stat.BC8 = 0;
080E  9104     BCF 0x4, 0, BANKED
411:               ep0Bi.Stat._byte |= MSB(byte_to_send);
0810  0102     MOVLB 0x2
0812  51AC     MOVF 0xAC, W, BANKED
0814  0104     MOVLB 0x4
0816  1304     IORWF 0x4, F, BANKED
412:               ep0Bi.Cnt = LSB(byte_to_send);
0818  C2AB     MOVFF byte_to_send, 0x405
081A  F405     NOP
413:           
414:               /*
415:                * Subtract the number of bytes just about to be sent from the total.
416:                */
417:               wCount._word = wCount._word - byte_to_send._word;
081C  0102     MOVLB 0x2
081E  51AB     MOVF 0xAB, W, BANKED
0820  5DA6     SUBWF 0xA6, W, BANKED
0822  6FA6     MOVWF 0xA6, BANKED
0824  51AC     MOVF 0xAC, W, BANKED
0826  59A7     SUBWFB 0xA7, W, BANKED
0828  6FA7     MOVWF 0xA7, BANKED
418:           
419:               pDst.bRam = (byte*)&CtrlTrfData;        // Set destination pointer
082A  0E18     MOVLW 0x18
082C  6FA4     MOVWF 0xA4, BANKED
082E  0E04     MOVLW 0x4
0830  6FA5     MOVWF 0xA5, BANKED
420:           
421:               if(usb_stat.ctrl_trf_mem == _ROM)       // Determine type of memory source
0832  0102     MOVLB 0x2
0834  A3B5     BTFSS 0xB5, 1, BANKED
0836  D00E     BRA 0x854
422:               {
423:                   while(byte_to_send._word)
0838  0102     MOVLB 0x2
083A  51AB     MOVF 0xAB, W, BANKED
083C  11AC     IORWF 0xAC, W, BANKED
083E  E012     BZ 0x864
0852  D7F2     BRA 0x838
424:                   {
425:                       *pDst.bRam = *pSrc.bRom;
0840  C2A2     MOVFF pSrc, TBLPTRL
0842  FFF6     NOP
0844  C2A3     MOVFF 0x2A3, TBLPTRH
0846  FFF7     NOP
0848  0008     TBLRD*
084A  50F5     MOVF TABLAT, W, ACCESS
084C  D863     RCALL __pa_0
426:                       pDst.bRam++;
427:                       pSrc.bRom++;
428:                       byte_to_send._word--;
084E  07AB     DECF 0xAB, F, BANKED
0850  5BAC     SUBWFB 0xAC, F, BANKED
429:                   }//end while(byte_to_send._word)
430:               }
431:               else // RAM
432:               {
433:                   while(byte_to_send._word)
0854  0102     MOVLB 0x2
0856  51AB     MOVF 0xAB, W, BANKED
0858  11AC     IORWF 0xAC, W, BANKED
085A  E004     BZ 0x864
0862  D7F8     BRA 0x854
434:                   {
435:                       *pDst.bRam = *pSrc.bRam;
085C  D86E     RCALL __pa_2
0914  C2A4     MOVFF pDst, FSR0L
0916  FFE9     NOP
0918  C2A5     MOVFF 0x2A5, FSR0H
091A  FFEA     NOP
091C  6EEF     MOVWF INDF0, ACCESS
093A  C2A2     MOVFF pSrc, FSR0L
093C  FFE9     NOP
093E  C2A3     MOVFF 0x2A3, FSR0H
0940  FFEA     NOP
0942  50EF     MOVF INDF0, W, ACCESS
0944  EF8A     GOTO 0x914
0946  F004     NOP
436:                       pDst.bRam++;
091E  2BA4     INCF 0xA4, F, BANKED
0920  0E00     MOVLW 0x0
0922  23A5     ADDWFC 0xA5, F, BANKED
437:                       pSrc.bRam++;
0924  2BA2     INCF 0xA2, F, BANKED
0926  23A3     ADDWFC 0xA3, F, BANKED
0928  0012     RETURN 0
438:                       byte_to_send._word--;
085E  07AB     DECF 0xAB, F, BANKED
0860  5BAC     SUBWFB 0xAC, F, BANKED
439:                   }//end while(byte_to_send._word)
440:               }//end if(usb_stat.ctrl_trf_mem == _ROM)
441:           
442:           }//end USBCtrlTrfTxService
0864  0012     RETURN 0
443:           
444:           /******************************************************************************
445:            * Function:        void USBCtrlTrfRxService(void)
446:            *
447:            * PreCondition:    pDst and wCount are setup properly.
448:            *                  pSrc is always &CtrlTrfData
449:            *                  usb_stat.ctrl_trf_mem is always _RAM.
450:            *                  wCount should be set to 0 at the start of each control
451:            *                  transfer.
452:            *
453:            * Input:           None
454:            *
455:            * Output:          None
456:            *
457:            * Side Effects:    None
458:            *
459:            * Overview:        *** This routine is only partially complete. Check for
460:            *                  new version of the firmware.
461:            *
462:            * Note:            None
463:            *****************************************************************************/
464:           void USBCtrlTrfRxService(void)
465:           {
466:               WORD byte_to_read;
467:           
468:               MSB(byte_to_read) = 0x03 & ep0Bo.Stat._byte;    // Filter out last 2 bits
0866  0E03     MOVLW 0x3
0868  0104     MOVLB 0x4
086A  1500     ANDWF __tmp_0, W, BANKED
086C  0102     MOVLB 0x2
086E  6FAE     MOVWF 0xAE, BANKED
469:               LSB(byte_to_read) = ep0Bo.Cnt;
0870  C401     MOVFF 0x401, byte_to_read
0872  F2AD     NOP
470:           
471:               /*
472:                * Accumulate total number of bytes read
473:                */
474:               wCount._word = wCount._word + byte_to_read._word;
0874  51A6     MOVF 0xA6, W, BANKED
0876  25AD     ADDWF 0xAD, W, BANKED
0878  6FA6     MOVWF 0xA6, BANKED
087A  51A7     MOVF 0xA7, W, BANKED
087C  21AE     ADDWFC 0xAE, W, BANKED
087E  6FA7     MOVWF 0xA7, BANKED
475:           
476:               pSrc.bRam = (byte*)&CtrlTrfData;
0880  0E18     MOVLW 0x18
0882  6FA2     MOVWF 0xA2, BANKED
0884  0E04     MOVLW 0x4
0886  6FA3     MOVWF 0xA3, BANKED
477:           
478:               while(byte_to_read._word)
0888  51AD     MOVF 0xAD, W, BANKED
088A  11AE     IORWF 0xAE, W, BANKED
088C  E004     BZ 0x896
0894  D7F9     BRA 0x888
479:               {
480:                   *pDst.bRam = *pSrc.bRam;
088E  D855     RCALL __pa_2
481:                   pDst.bRam++;
482:                   pSrc.bRam++;
483:                   byte_to_read._word--;
0890  07AD     DECF 0xAD, F, BANKED
0892  5BAE     SUBWFB 0xAE, F, BANKED
484:               }//end while(byte_to_read._word)
485:           
486:           }//end USBCtrlTrfRxService
0896  0012     RETURN 0
487:           
488:           /******************************************************************************
489:            * Function:        void USBCtrlEPServiceComplete(void)
490:            *
491:            * PreCondition:    None
492:            *
493:            * Input:           None
494:            *
495:            * Output:          None
496:            *
497:            * Side Effects:    None
498:            *
499:            * Overview:        This routine wrap up the ramaining tasks in servicing
500:            *                  a Setup Request. Its main task is to set the endpoint
501:            *                  controls appropriately for a given situation. See code
502:            *                  below.
503:            *                  There are three main scenarios:
504:            *                  a) There was no handler for the Request, in this case
505:            *                     a STALL should be sent out.
506:            *                  b) The host has requested a read control transfer,
507:            *                     endpoints are required to be setup in a specific way.
508:            *                  c) The host has requested a write control transfer, or
509:            *                     a control data stage is not required, endpoints are
510:            *                     required to be setup in a specific way.
511:            *
512:            *                  Packet processing is resumed by clearing PKTDIS bit.
513:            *
514:            * Note:            None
515:            *****************************************************************************/
516:           void USBCtrlEPServiceComplete(void)
517:           {
518:               /********************************************************************
519:               Bug Fix: May 14, 2007 (#AF1)
520:               *********************************************************************
521:               See silicon errata for 4550 A3. Now clearing PKTDIS before re-arming
522:               any EP0 endpoints.
523:               ********************************************************************/
524:               /*
525:                * PKTDIS bit is set when a Setup Transaction is received.
526:                * Clear to resume packet processing.
527:                */
528:               UCONbits.PKTDIS = 0;
0898  986D     BCF UCON, 4, ACCESS
529:               /*******************************************************************/
530:           
531:               if(ctrl_trf_session_owner == MUID_NULL)
089A  0102     MOVLB 0x2
089C  51A1     MOVF PacketFromPC, W, BANKED
089E  E105     BNZ 0x8AA
532:               {
533:                   /*
534:                    * If no one knows how to service this request then stall.
535:                    * Must also prepare EP0 to receive the next SETUP transaction.
536:                    */
537:                   ep0Bo.Cnt = EP0_BUFF_SIZE;
08A0  D844     RCALL __pa_1
538:                   ep0Bo.ADR = (byte*)&SetupPkt;
539:           
540:                   ep0Bo.Stat._byte = _USIE|_BSTALL;
08A2  0E84     MOVLW 0x84
08A4  6F00     MOVWF __tmp_0, BANKED
541:                   ep0Bi.Stat._byte = _USIE|_BSTALL;
08A6  0104     MOVLB 0x4
542:               }
543:               else    // A module has claimed ownership of the control transfer session.
08A8  D01D     BRA 0x8E4
544:               {
545:                   if(SetupPkt.DataDir == DEV_TO_HOST)
08AA  0104     MOVLB 0x4
08AC  AF10     BTFSS 0x10, 7, BANKED
08AE  D01C     BRA 0x8E8
546:                   {
547:                       if(SetupPkt.wLength < wCount._word)
08B0  0102     MOVLB 0x2
08B2  51A6     MOVF 0xA6, W, BANKED
08B4  0104     MOVLB 0x4
08B6  5D16     SUBWF 0x16, W, BANKED
08B8  0102     MOVLB 0x2
08BA  51A7     MOVF 0xA7, W, BANKED
08BC  0104     MOVLB 0x4
08BE  5917     SUBWFB 0x17, W, BANKED
08C0  E204     BC 0x8CA
548:                           wCount._word = SetupPkt.wLength;
08C2  C416     MOVFF 0x416, wCount
08C4  F2A6     NOP
08C6  C417     MOVFF 0x417, 0x2A7
08C8  F2A7     NOP
549:                       USBCtrlTrfTxService();
08CA  DF89     RCALL USBCtrlTrfTxService
550:                       ctrl_trf_state = CTRL_TRF_TX;
08CC  0102     MOVLB 0x2
08CE  0E01     MOVLW 0x1
08D0  6FA0     MOVWF 0xA0, BANKED
551:                       /*
552:                        * Control Read:
553:                        * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
554:                        * 1. Prepare OUT EP to respond to early termination
555:                        *
556:                        * NOTE:
557:                        * If something went wrong during the control transfer,
558:                        * the last status stage may not be sent by the host.
559:                        * When this happens, two different things could happen
560:                        * depending on the host.
561:                        * a) The host could send out a RESET.
562:                        * b) The host could send out a new SETUP transaction
563:                        *    without sending a RESET first.
564:                        * To properly handle case (b), the OUT EP must be setup
565:                        * to receive either a zero length OUT transaction, or a
566:                        * new SETUP transaction.
567:                        *
568:                        * Since the SETUP transaction requires the DTS bit to be
569:                        * DAT0 while the zero length OUT status requires the DTS
570:                        * bit to be DAT1, the DTS bit check by the hardware should
571:                        * be disabled. This way the SIE could accept either of
572:                        * the two transactions.
573:                        *
574:                        * Furthermore, the Cnt byte should be set to prepare for
575:                        * the SETUP data (8-byte or more), and the buffer address
576:                        * should be pointed to SetupPkt.
577:                        */
578:                       ep0Bo.Cnt = EP0_BUFF_SIZE;
08D2  D82B     RCALL __pa_1
092A  0104     MOVLB 0x4
092C  0E08     MOVLW 0x8
092E  6F01     MOVWF 0x1, BANKED
579:                       ep0Bo.ADR = (byte*)&SetupPkt;
0930  0E10     MOVLW 0x10
0932  6F02     MOVWF 0x2, BANKED
0934  0E04     MOVLW 0x4
0936  6F03     MOVWF 0x3, BANKED
0938  0012     RETURN 0
580:                       ep0Bo.Stat._byte = _USIE;           // Note: DTSEN is 0!
08D4  0E80     MOVLW 0x80
08D6  6F00     MOVWF __tmp_0, BANKED
581:           
582:                       /*
583:                        * 2. Prepare IN EP to transfer data, Cnt should have
584:                        *    been initialized by responsible request owner.
585:                        */
586:                       ep0Bi.ADR = (byte*)&CtrlTrfData;
08D8  0104     MOVLB 0x4
08DA  0E18     MOVLW 0x18
08DC  6F06     MOVWF 0x6, BANKED
08DE  0E04     MOVLW 0x4
08E0  6F07     MOVWF 0x7, BANKED
587:                       ep0Bi.Stat._byte = _USIE|_DAT1|_DTSEN;
08E2  0EC8     MOVLW 0xC8
08E4  6F04     MOVWF 0x4, BANKED
588:                   }
589:                   else    // (SetupPkt.DataDir == HOST_TO_DEV)
08E6  0012     RETURN 0
590:                   {
591:                       ctrl_trf_state = CTRL_TRF_RX;
08E8  0102     MOVLB 0x2
08EA  0E02     MOVLW 0x2
08EC  6FA0     MOVWF 0xA0, BANKED
592:                       /*
593:                        * Control Write:
594:                        * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
595:                        *
596:                        * 1. Prepare IN EP to respond to early termination
597:                        *
598:                        *    This is the same as a Zero Length Packet Response
599:                        *    for control transfer without a data stage
600:                        */
601:                       ep0Bi.Cnt = 0;
08EE  0104     MOVLB 0x4
08F0  6B05     CLRF 0x5, BANKED
602:                       ep0Bi.Stat._byte = _USIE|_DAT1|_DTSEN;
08F2  0EC8     MOVLW 0xC8
08F4  6F04     MOVWF 0x4, BANKED
603:           
604:                       /*
605:                        * 2. Prepare OUT EP to receive data.
606:                        */
607:                       ep0Bo.Cnt = EP0_BUFF_SIZE;
08F6  0104     MOVLB 0x4
08F8  0E08     MOVLW 0x8
08FA  6F01     MOVWF 0x1, BANKED
608:                       ep0Bo.ADR = (byte*)&CtrlTrfData;
08FC  0E18     MOVLW 0x18
08FE  6F02     MOVWF 0x2, BANKED
0900  0E04     MOVLW 0x4
0902  6F03     MOVWF 0x3, BANKED
609:                       ep0Bo.Stat._byte = _USIE|_DAT1|_DTSEN;
0904  0EC8     MOVLW 0xC8
0906  6F00     MOVWF __tmp_0, BANKED
610:                   }//end if(SetupPkt.DataDir == DEV_TO_HOST)
611:               }//end if(ctrl_trf_session_owner == MUID_NULL)
612:           
613:           }//end USBCtrlEPServiceComplete
0908  0012     RETURN 0
614:           
615:           /******************************************************************************
616:            * Function:        void USBPrepareForNextSetupTrf(void)
617:            *
618:            * PreCondition:    None
619:            *
620:            * Input:           None
621:            *
622:            * Output:          None
623:            *
624:            * Side Effects:    None
625:            *
626:            * Overview:        The routine forces EP0 OUT to be ready for a new Setup
627:            *                  transaction, and forces EP0 IN to be owned by CPU.
628:            *
629:            * Note:            None
630:            *****************************************************************************/
631:           void USBPrepareForNextSetupTrf(void)
632:           {
633:               ctrl_trf_state = WAIT_SETUP;            // See usbctrltrf.h
090A  0102     MOVLB 0x2
090C  6BA0     CLRF 0xA0, BANKED
634:           
635:               /********************************************************************
636:               Bug Fix: May 14, 2007 (#F3)
637:               *********************************************************************
638:               In the original firmware, if an IN token is sent by the host
639:               before a SETUP token is sent, the firmware would respond with an ACK.
640:               This is not a correct response, the firmware should have sent a STALL.
641:               This is a minor non-compliance since a compliant host should not
642:               send an IN before sending a SETUP token. The fix allows a SETUP
643:               transaction to be accepted while stalling IN transactions.
644:               
645:               Although this fix is known, it is not implemented because it
646:               breaks the #AF1 fix in USBCtrlEPServiceComplete().
647:               Since #AF1 fix is more important, this fix, #F3 is commented out.
648:               ********************************************************************/
649:               ep0Bi.Stat._byte = _UCPU;               // Should be removed
090E  0104     MOVLB 0x4
0910  6B04     CLRF 0x4, BANKED
650:               //ep0Bi.Stat._byte = _USIE|_BSTALL;     // Should be added #F3
651:           
652:           
653:           }//end USBPrepareForNextSetupTrf
0912  0012     RETURN 0
654:           
655:           
656:           
657:           /** EOF usbctrltrf.c *********************************************************/
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/usb9.c  ------------------------------------------------
1:             /*********************************************************************
2:              *
3:              *                Microchip USB C18 Firmware Version 1.3
4:              *
5:              *********************************************************************
6:              * FileName:        usb9.c
7:              * Dependencies:    See INCLUDES section below
8:              * Processor:       PIC18
9:              * Compiler:        C18 3.11+
10:             * Company:         Microchip Technology, Inc.
11:             *
12:             * Software License Agreement
13:             *
14:             * The software supplied herewith by Microchip Technology Incorporated
15:             * (the ?Company?) for its PICmicro Microcontroller is intended and
16:             * supplied to you, the Company?s customer, for use solely and
17:             * exclusively on Microchip PICmicro Microcontroller products. The
18:             * software is owned by the Company and/or its supplier, and is
19:             * protected under applicable copyright laws. All rights are reserved.
20:             * Any use in violation of the foregoing restrictions may subject the
21:             * user to criminal sanctions under applicable laws, as well as to
22:             * civil liability for the breach of the terms and conditions of this
23:             * license.
24:             *
25:             * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
26:             * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:             * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:             * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:             * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:             *
32:             * Author               Date        Comment
33:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
34:             * Rawin Rojvanit       11/19/04    Original.
35:             * Rawin Rojvanit       01/04/08    Bug fixes.
36:             ********************************************************************/
37:            
38:            /** I N C L U D E S **********************************************************/
39:            #include <p18cxxx.h>
40:            #include "typedefs.h"
41:            #include "usb.h"
42:            #include "io_cfg.h"                     // Required for self_power status
43:            
44:            /** V A R I A B L E S ********************************************************/
45:            #pragma udata
46:            
47:            /** P R I V A T E  P R O T O T Y P E S ***************************************/
48:            void USBStdGetDscHandler(void);
49:            void USBStdSetCfgHandler(void);
50:            void USBStdGetStatusHandler(void);
51:            void USBStdFeatureReqHandler(void);
52:            
53:            /** D E C L A R A T I O N S **************************************************/
54:            #pragma code
55:            /******************************************************************************
56:             * Function:        void USBCheckStdRequest(void)
57:             *
58:             * PreCondition:    None
59:             *
60:             * Input:           None
61:             *
62:             * Output:          None
63:             *
64:             * Side Effects:    None
65:             *
66:             * Overview:        This routine checks the setup data packet to see if it
67:             *                  knows how to handle it
68:             *
69:             * Note:            None
70:             *****************************************************************************/
71:            void USBCheckStdRequest(void)
72:            {   
73:                if(SetupPkt.RequestType != STANDARD) return;
0948  0104     MOVLB 0x4
094A  5110     MOVF 0x10, W, BANKED
094C  0B60     ANDLW 0x60
094E  42E8     RRNCF WREG, F, ACCESS
0950  42E8     RRNCF WREG, F, ACCESS
0952  42E8     RRNCF WREG, F, ACCESS
0954  42E8     RRNCF WREG, F, ACCESS
0956  42E8     RRNCF WREG, F, ACCESS
0958  0900     IORLW 0x0
095A  E001     BZ 0x95E
095C  0012     RETURN 0
74:                
75:                switch(SetupPkt.bRequest)
095E  5111     MOVF 0x11, W, BANKED
0960  0A07     XORLW 0x7
0962  E040     BZ 0x9E4
0964  0A0B     XORLW 0xB
0966  E03E     BZ 0x9E4
0968  0A07     XORLW 0x7
096A  E033     BZ 0x9D2
096C  0A01     XORLW 0x1
096E  E023     BZ 0x9B6
0970  0A0B     XORLW 0xB
0972  E01F     BZ 0x9B2
0974  0A02     XORLW 0x2
0976  E01D     BZ 0x9B2
0978  0A03     XORLW 0x3
097A  E019     BZ 0x9AE
097C  0A08     XORLW 0x8
097E  E010     BZ 0x9A0
0980  0A01     XORLW 0x1
0982  E00C     BZ 0x99C
0984  0A0F     XORLW 0xF
0986  E008     BZ 0x998
0988  0A03     XORLW 0x3
098A  E001     BZ 0x98E
098C  0012     RETURN 0
76:                {
77:                    case SET_ADR:
78:                        ctrl_trf_session_owner = MUID_USB9;
098E  D90D     RCALL __pa_4
79:                        usb_device_state = ADR_PENDING_STATE;       // Update state only
0990  0102     MOVLB 0x2
0992  0E04     MOVLW 0x4
0994  6FB4     MOVWF 0xB4, BANKED
80:                        /* See USBCtrlTrfInHandler() in usbctrltrf.c for the next step */
81:                        break;
0996  0012     RETURN 0
82:                    case GET_DSC:
83:                        USBStdGetDscHandler();
0998  EFF3     GOTO 0x9E6
099A  F004     NOP
84:                        break;
85:                    case SET_CFG:
86:                        USBStdSetCfgHandler();
099C  EF2A     GOTO 0xA54
099E  F005     NOP
87:                        break;
88:                    case GET_CFG:
89:                        ctrl_trf_session_owner = MUID_USB9;
09A0  D904     RCALL __pa_4
90:                        pSrc.bRam = (byte*)&usb_active_cfg;         // Set Source
09A2  0102     MOVLB 0x2
09A4  0EB6     MOVLW 0xB6
09A6  6FA2     MOVWF 0xA2, BANKED
09A8  0E02     MOVLW 0x2
09AA  6FA3     MOVWF 0xA3, BANKED
91:                        usb_stat.ctrl_trf_mem = _RAM;               // Set memory type
92:                        LSB(wCount) = 1;                            // Set data count
93:                        break;
09AC  D00C     BRA 0x9C6
94:                    case GET_STATUS:
95:                        USBStdGetStatusHandler();
09AE  EF49     GOTO 0xA92
09B0  F005     NOP
96:                        break;
97:                    case CLR_FEATURE:
98:                    case SET_FEATURE:
99:                        USBStdFeatureReqHandler();
09B2  EF79     GOTO 0xAF2
09B4  F005     NOP
100:                       break;
101:                   case GET_INTF:
102:                       ctrl_trf_session_owner = MUID_USB9;
09B6  D8FD     RCALL __pa_5
103:                       pSrc.bRam = (byte*)&usb_alt_intf+SetupPkt.bIntfID;  // Set source
09B8  0102     MOVLB 0x2
09BA  6FA2     MOVWF 0xA2, BANKED
09BC  6BA3     CLRF 0xA3, BANKED
09BE  0EB7     MOVLW 0xB7
09C0  27A2     ADDWF 0xA2, F, BANKED
09C2  0E02     MOVLW 0x2
09C4  23A3     ADDWFC 0xA3, F, BANKED
104:                       usb_stat.ctrl_trf_mem = _RAM;               // Set memory type
09C6  0102     MOVLB 0x2
09C8  93B5     BCF 0xB5, 1, BANKED
105:                       LSB(wCount) = 1;                            // Set data count
09CA  0102     MOVLB 0x2
09CC  0E01     MOVLW 0x1
09CE  6FA6     MOVWF 0xA6, BANKED
106:                       break;
09D0  0012     RETURN 0
107:                   case SET_INTF:
108:                       ctrl_trf_session_owner = MUID_USB9;
09D2  D8EF     RCALL __pa_5
109:                       usb_alt_intf[SetupPkt.bIntfID] = SetupPkt.bAltID;
09D4  6AEA     CLRF FSR0H, ACCESS
09D6  0FB7     ADDLW 0xB7
09D8  6EE9     MOVWF FSR0L, ACCESS
09DA  0E02     MOVLW 0x2
09DC  22EA     ADDWFC FSR0H, F, ACCESS
09DE  C412     MOVFF 0x412, INDF0
09E0  FFEF     NOP
110:                       break;
09E2  0012     RETURN 0
111:                   case SET_DSC:
112:                   case SYNCH_FRAME:
113:                   default:
114:                       break;
115:               }//end switch
116:               
117:           }//end USBCheckStdRequest
09E4  0012     RETURN 0
118:           
119:           /******************************************************************************
120:            * Function:        void USBStdGetDscHandler(void)
121:            *
122:            * PreCondition:    None
123:            *
124:            * Input:           None
125:            *
126:            * Output:          None
127:            *
128:            * Side Effects:    None
129:            *
130:            * Overview:        This routine handles the standard GET_DESCRIPTOR request.
131:            *                  It utilizes tables dynamically looks up descriptor size.
132:            *                  This routine should never have to be modified if the tables
133:            *                  in usbdsc.c are declared correctly.
134:            *
135:            * Note:            None
136:            *****************************************************************************/
137:           void USBStdGetDscHandler(void)
138:           {
139:               if(SetupPkt.bmRequestType == 0x80)
09E6  0E80     MOVLW 0x80
09E8  0104     MOVLB 0x4
09EA  5D10     SUBWF 0x10, W, BANKED
09EC  E132     BNZ 0xA52
140:               {
141:                   switch(SetupPkt.bDscType)
09EE  5113     MOVF 0x13, W, BANKED
09F0  0A03     XORLW 0x3
09F2  E01F     BZ 0xA32
09F4  0A01     XORLW 0x1
09F6  E00A     BZ 0xA0C
09F8  0A03     XORLW 0x3
09FA  E129     BNZ 0xA4E
142:                   {
143:                       case DSC_DEV:
144:                           ctrl_trf_session_owner = MUID_USB9;
09FC  D8D6     RCALL __pa_4
145:                           pSrc.bRom = (rom byte*)&device_dsc;
09FE  0102     MOVLB 0x2
0A00  0EBC     MOVLW 0xBC
0A02  6FA2     MOVWF 0xA2, BANKED
0A04  0E0E     MOVLW 0xE
0A06  6FA3     MOVWF 0xA3, BANKED
146:                           wCount._word = sizeof(device_dsc);          // Set data count
0A08  0E12     MOVLW 0x12
147:                           break;
0A0A  D01E     BRA 0xA48
148:                       case DSC_CFG:
149:                           ctrl_trf_session_owner = MUID_USB9;
0A0C  D8B4     RCALL __pa_1
0B76  D819     RCALL __pa_4
0BAA  0102     MOVLB 0x2
0BAC  0E01     MOVLW 0x1
0BAE  6FA1     MOVWF PacketFromPC, BANKED
0BB0  0012     RETURN 0
150:                           pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
0A0E  0E72     MOVLW 0x72
0A10  26F6     ADDWF TBLPTRL, F, ACCESS
0A12  0E0F     MOVLW 0xF
0A14  D8C2     RCALL __pa_3
0B78  0104     MOVLB 0x4
0B7A  5112     MOVF 0x12, W, BANKED
0B7C  6EF6     MOVWF TBLPTRL, ACCESS
0B7E  6AF7     CLRF TBLPTRH, ACCESS
0B80  90D8     BCF STATUS, 0, ACCESS
0B82  36F6     RLCF TBLPTRL, F, ACCESS
0B84  36F7     RLCF TBLPTRH, F, ACCESS
0B86  0012     RETURN 0
0B9A  22F7     ADDWFC TBLPTRH, F, ACCESS
0B9C  0009     TBLRD*+
0B9E  CFF5     MOVFF TABLAT, pSrc
0BA0  F2A2     NOP
0BA2  000A     TBLRD*-
0BA4  CFF5     MOVFF TABLAT, 0x2A3
0BA6  F2A3     NOP
0BA8  0012     RETURN 0
151:                           wCount._word = *(pSrc.wRom+1);              // Set data count
0A16  0E02     MOVLW 0x2
0A18  0102     MOVLB 0x2
0A1A  6AF7     CLRF TBLPTRH, ACCESS
0A1C  25A2     ADDWF 0xA2, W, BANKED
0A1E  6EF6     MOVWF TBLPTRL, ACCESS
0A20  51A3     MOVF 0xA3, W, BANKED
0A22  22F7     ADDWFC TBLPTRH, F, ACCESS
0A24  0009     TBLRD*+
0A26  CFF5     MOVFF TABLAT, wCount
0A28  F2A6     NOP
0A2A  000A     TBLRD*-
0A2C  CFF5     MOVFF TABLAT, 0x2A7
0A2E  F2A7     NOP
152:                           break;
0A30  D00E     BRA 0xA4E
153:                       case DSC_STR:
154:                           ctrl_trf_session_owner = MUID_USB9;
0A32  D8A1     RCALL __pa_1
155:                           pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0A34  0E76     MOVLW 0x76
0A36  26F6     ADDWF TBLPTRL, F, ACCESS
0A38  0E0F     MOVLW 0xF
0A3A  D8AF     RCALL __pa_3
156:                           wCount._word = *pSrc.bRom;                  // Set data count
0A3C  C2A2     MOVFF pSrc, TBLPTRL
0A3E  FFF6     NOP
0A40  C2A3     MOVFF 0x2A3, TBLPTRH
0A42  FFF7     NOP
0A44  0008     TBLRD*
0A46  50F5     MOVF TABLAT, W, ACCESS
0A48  0102     MOVLB 0x2
0A4A  6FA6     MOVWF 0xA6, BANKED
0A4C  6BA7     CLRF 0xA7, BANKED
157:                           break;
158:                   }//end switch
159:                   
160:                   usb_stat.ctrl_trf_mem = _ROM;                       // Set memory type
0A4E  0102     MOVLB 0x2
0A50  83B5     BSF 0xB5, 1, BANKED
161:               }//end if
162:           }//end USBStdGetDscHandler
0A52  0012     RETURN 0
163:           
164:           /******************************************************************************
165:            * Function:        void USBStdSetCfgHandler(void)
166:            *
167:            * PreCondition:    None
168:            *
169:            * Input:           None
170:            *
171:            * Output:          None
172:            *
173:            * Side Effects:    None
174:            *
175:            * Overview:        This routine first disables all endpoints by clearing
176:            *                  UEP registers. It then configures (initializes) endpoints
177:            *                  specified in the modifiable section.
178:            *
179:            * Note:            None
180:            *****************************************************************************/
181:           void USBStdSetCfgHandler(void)
182:           {
183:               ctrl_trf_session_owner = MUID_USB9;
0A54  D8AA     RCALL __pa_4
184:               mDisableEP1to7();                          // See usbdrv.h
0A56  6A71     CLRF UEP1, ACCESS
0A58  6A72     CLRF UEP2, ACCESS
0A5A  6A73     CLRF UEP3, ACCESS
0A5C  6A74     CLRF UEP4, ACCESS
0A5E  6A75     CLRF UEP5, ACCESS
0A60  6A76     CLRF UEP6, ACCESS
0A62  6A77     CLRF UEP7, ACCESS
185:               ClearArray((byte*)&usb_alt_intf,MAX_NUM_INT);
0A64  0102     MOVLB 0x2
0A66  6FB3     MOVWF 0xB3, BANKED
0A68  0102     MOVLB 0x2
0A6A  0EB7     MOVLW 0xB7
0A6C  6FB1     MOVWF 0xB1, BANKED
0A6E  0E02     MOVLW 0x2
0A70  6FB2     MOVWF 0xB2, BANKED
0A72  EC52     CALL 0xEA4, 0
0A74  F007     NOP
186:               usb_active_cfg = SetupPkt.bCfgValue;
0A76  C412     MOVFF 0x412, usb_active_cfg
0A78  F2B6     NOP
187:               if(SetupPkt.bCfgValue == 0)
0A7A  0104     MOVLB 0x4
0A7C  5112     MOVF 0x12, W, BANKED
0A7E  E104     BNZ 0xA88
188:                   usb_device_state = ADDRESS_STATE;
0A80  0102     MOVLB 0x2
0A82  0E05     MOVLW 0x5
0A84  6FB4     MOVWF 0xB4, BANKED
189:               else
0A86  0012     RETURN 0
190:               {
191:                   usb_device_state = CONFIGURED_STATE;
0A88  0102     MOVLB 0x2
0A8A  0E06     MOVLW 0x6
0A8C  6FB4     MOVWF 0xB4, BANKED
192:           
193:                   /* Modifiable Section */
194:                   
195:                   #if defined(USB_USE_HID)                // See autofiles\usbcfg.h
196:                   HIDInitEP();
0A8E  EF46     GOTO 0xC8C
0A90  F006     NOP
197:                   #endif
198:                   
199:                   /* End modifiable section */
200:           
201:               }//end if(SetupPkt.bcfgValue == 0)
202:           }//end USBStdSetCfgHandler
203:           
204:           /******************************************************************************
205:            * Function:        void USBStdGetStatusHandler(void)
206:            *
207:            * PreCondition:    None
208:            *
209:            * Input:           None
210:            *
211:            * Output:          None
212:            *
213:            * Side Effects:    None
214:            *
215:            * Overview:        This routine handles the standard GET_STATUS request
216:            *
217:            * Note:            None
218:            *****************************************************************************/
219:           void USBStdGetStatusHandler(void)
220:           {
221:               CtrlTrfData._byte0 = 0;                         // Initialize content
0A92  0104     MOVLB 0x4
0A94  6B18     CLRF 0x18, BANKED
222:               CtrlTrfData._byte1 = 0;
0A96  6B19     CLRF 0x19, BANKED
223:                   
224:               switch(SetupPkt.Recipient)
0A98  0104     MOVLB 0x4
0A9A  5110     MOVF 0x10, W, BANKED
0A9C  0B1F     ANDLW 0x1F
0A9E  0A02     XORLW 0x2
0AA0  E00D     BZ 0xABC
0AA2  0A03     XORLW 0x3
0AA4  E009     BZ 0xAB8
0AA6  0A01     XORLW 0x1
0AA8  E116     BNZ 0xAD6
225:               {
226:                   case RCPT_DEV:
227:                       ctrl_trf_session_owner = MUID_USB9;
0AAA  D87F     RCALL __pa_4
228:                       /*
229:                        * _byte0: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
230:                        *         bit1: RemoteWakeup        [0] Disabled    [1] Enabled
231:                        */
232:           
233:           /********************************************************************
234:           Bug Fix: January 4, 2008
235:           *********************************************************************
236:           Removed an extra '0' from the code:
237:           CtrlTrfData._byte0|=0b00000001;
238:           ********************************************************************/
239:                       if(self_power == 1)                     // self_power defined in io_cfg.h
240:                           CtrlTrfData._byte0|=0b00000001;     // Set bit0
241:           /*******************************************************************/
242:           
243:                       if(usb_stat.RemoteWakeup == 1)          // usb_stat defined in usbmmap.c
0AAC  0102     MOVLB 0x2
0AAE  A1B5     BTFSS 0xB5, 0, BANKED
0AB0  D012     BRA 0xAD6
244:                           CtrlTrfData._byte0|=0b00000010;     // Set bit1
0AB2  0104     MOVLB 0x4
0AB4  8318     BSF 0x18, 1, BANKED
245:                       break;
0AB6  D00F     BRA 0xAD6
246:                   case RCPT_INTF:
247:                       ctrl_trf_session_owner = MUID_USB9;     // No data to update
0AB8  D878     RCALL __pa_4
248:                       break;
0ABA  D00D     BRA 0xAD6
249:                   case RCPT_EP:
250:                       ctrl_trf_session_owner = MUID_USB9;
0ABC  D850     RCALL __pa_0
0B5E  D829     RCALL __pa_5
0BB2  DFFB     RCALL __pa_4
251:                       /*
252:                        * _byte0: bit0: Halt Status [0] Not Halted [1] Halted
253:                        */
254:                       pDst.bRam = (byte*)&ep0Bo+(SetupPkt.EPNum*8)+(SetupPkt.EPDir*4);
0ABE  E001     BZ 0xAC2
0AC0  0E01     MOVLW 0x1
0AC2  D862     RCALL __pa_2
0B60  0B0F     ANDLW 0xF
0B62  0D08     MULLW 0x8
0B64  50F3     MOVF PRODL, W, ACCESS
0B66  6A01     CLRF 0x1, ACCESS
0B68  0F00     ADDLW 0x0
0B6A  6E00     MOVWF __tmp_0, ACCESS
0B6C  0E04     MOVLW 0x4
0B6E  2201     ADDWFC 0x1, F, ACCESS
0B70  5114     MOVF 0x14, W, BANKED
0B72  0B80     ANDLW 0x80
0B74  0012     RETURN 0
0B88  0D04     MULLW 0x4
0B8A  50F3     MOVF PRODL, W, ACCESS
0B8C  0102     MOVLB 0x2
0B8E  2400     ADDWF __tmp_0, W, ACCESS
0B90  6FA4     MOVWF 0xA4, BANKED
0B92  0E00     MOVLW 0x0
0B94  2001     ADDWFC 0x1, W, ACCESS
0B96  6FA5     MOVWF 0xA5, BANKED
0B98  0012     RETURN 0
0BB4  0104     MOVLB 0x4
0BB6  5114     MOVF 0x14, W, BANKED
0BB8  0012     RETURN 0
255:                       if(*pDst.bRam & _BSTALL)    // Use _BSTALL as a bit mask
0AC4  C2A4     MOVFF pDst, FSR0L
0AC6  FFE9     NOP
0AC8  6EEA     MOVWF FSR0H, ACCESS
0ACA  50EF     MOVF INDF0, W, ACCESS
0ACC  0B04     ANDLW 0x4
0ACE  E003     BZ 0xAD6
256:                           CtrlTrfData._byte0=0x01;// Set bit0
0AD0  0104     MOVLB 0x4
0AD2  0E01     MOVLW 0x1
0AD4  6F18     MOVWF 0x18, BANKED
257:                       break;
258:               }//end switch
259:               
260:               if(ctrl_trf_session_owner == MUID_USB9)
0AD6  0102     MOVLB 0x2
0AD8  05A1     DECF PacketFromPC, W, BANKED
0ADA  E10A     BNZ 0xAF0
261:               {
262:                   pSrc.bRam = (byte*)&CtrlTrfData;            // Set Source
0ADC  0102     MOVLB 0x2
0ADE  0E18     MOVLW 0x18
0AE0  6FA2     MOVWF 0xA2, BANKED
0AE2  0E04     MOVLW 0x4
0AE4  6FA3     MOVWF 0xA3, BANKED
263:                   usb_stat.ctrl_trf_mem = _RAM;               // Set memory type
0AE6  0102     MOVLB 0x2
0AE8  93B5     BCF 0xB5, 1, BANKED
264:                   LSB(wCount) = 2;                            // Set data count
0AEA  0102     MOVLB 0x2
0AEC  0E02     MOVLW 0x2
0AEE  6FA6     MOVWF 0xA6, BANKED
265:               }//end if(...)
266:           }//end USBStdGetStatusHandler
0AF0  0012     RETURN 0
267:           
268:           /******************************************************************************
269:            * Function:        void USBStdFeatureReqHandler(void)
270:            *
271:            * PreCondition:    None
272:            *
273:            * Input:           None
274:            *
275:            * Output:          None
276:            *
277:            * Side Effects:    None
278:            *
279:            * Overview:        This routine handles the standard SET & CLEAR FEATURES
280:            *                  requests
281:            *
282:            * Note:            None
283:            *****************************************************************************/
284:           void USBStdFeatureReqHandler(void)
285:           {
286:               if((SetupPkt.bFeature == DEVICE_REMOTE_WAKEUP)&&
0AF2  0104     MOVLB 0x4
0AF4  0512     DECF 0x12, W, BANKED
287:                  (SetupPkt.Recipient == RCPT_DEV))
0AF6  E10E     BNZ 0xB14
0AF8  5110     MOVF 0x10, W, BANKED
0AFA  0B1F     ANDLW 0x1F
0AFC  0900     IORLW 0x0
0AFE  E10A     BNZ 0xB14
288:               {
289:                   ctrl_trf_session_owner = MUID_USB9;
0B00  D854     RCALL __pa_4
290:                   if(SetupPkt.bRequest == SET_FEATURE)
0B02  0E03     MOVLW 0x3
0B04  0104     MOVLB 0x4
0B06  5D11     SUBWF 0x11, W, BANKED
0B08  E103     BNZ 0xB10
291:                       usb_stat.RemoteWakeup = 1;
0B0A  0102     MOVLB 0x2
0B0C  81B5     BSF 0xB5, 0, BANKED
292:                   else
0B0E  D002     BRA 0xB14
293:                       usb_stat.RemoteWakeup = 0;
0B10  0102     MOVLB 0x2
0B12  91B5     BCF 0xB5, 0, BANKED
294:               }//end if
295:               
296:               if((SetupPkt.bFeature == ENDPOINT_HALT)&&
0B14  0104     MOVLB 0x4
0B16  5112     MOVF 0x12, W, BANKED
297:                  (SetupPkt.Recipient == RCPT_EP)&&
0B18  E121     BNZ 0xB5C
0B1A  5110     MOVF 0x10, W, BANKED
0B1C  0B1F     ANDLW 0x1F
0B1E  0802     SUBLW 0x2
0B20  E11D     BNZ 0xB5C
298:                  (SetupPkt.EPNum != 0))
0B22  5114     MOVF 0x14, W, BANKED
0B24  0B0F     ANDLW 0xF
0B26  0900     IORLW 0x0
0B28  E019     BZ 0xB5C
299:               {
300:                   ctrl_trf_session_owner = MUID_USB9;
0B2A  D819     RCALL __pa_0
301:                   /* Must do address calculation here */
302:                   pDst.bRam = (byte*)&ep0Bo+(SetupPkt.EPNum*8)+(SetupPkt.EPDir*4);
0B2C  E001     BZ 0xB30
0B2E  0E01     MOVLW 0x1
0B30  D82B     RCALL __pa_2
303:                   
304:                   if(SetupPkt.bRequest == SET_FEATURE)
0B32  0E03     MOVLW 0x3
0B34  0104     MOVLB 0x4
0B36  5D11     SUBWF 0x11, W, BANKED
0B38  E102     BNZ 0xB3E
305:                       *pDst.bRam = _USIE|_BSTALL;
0B3A  0E84     MOVLW 0x84
306:                   else
0B3C  D003     BRA 0xB44
307:                   {
308:           /********************************************************************
309:           Bug Fix: January 4, 2008
310:           *********************************************************************
311:           Added '|DAT1' to force a halted IN endpoint to reinitialize to send
312:           out DAT0 on the next transaction.
313:           ********************************************************************/
314:                       if(SetupPkt.EPDir == 1) // IN
0B3E  AF14     BTFSS 0x14, 7, BANKED
0B40  D007     BRA 0xB50
315:                           *pDst.bRam = _UCPU|_DAT1;
0B42  0E40     MOVLW 0x40
0B44  C2A4     MOVFF pDst, FSR0L
0B46  FFE9     NOP
0B48  C2A5     MOVFF 0x2A5, FSR0H
0B4A  FFEA     NOP
0B4C  6EEF     MOVWF INDF0, ACCESS
316:                       else
0B4E  0012     RETURN 0
317:                           *pDst.bRam = _USIE|_DAT0|_DTSEN;
0B50  0E88     MOVLW 0x88
0B52  C2A4     MOVFF pDst, FSR0L
0B54  FFE9     NOP
0B56  C2A5     MOVFF 0x2A5, FSR0H
0B58  FFEA     NOP
0B5A  6EEF     MOVWF INDF0, ACCESS
318:           /*******************************************************************/
319:                   }//end if
320:               }//end if
321:           }//end USBStdFeatureReqHandler
0B5C  0012     RETURN 0
322:           
323:           /** EOF usb9.c ***************************************************************/
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/main.c  ------------------------------------------------
1:             /*********************************************************************
2:              *
3:              *   Microchip USB HID Bootloader for PIC18 (Non-J Family) USB Microcontrollers
4:              *
5:              *********************************************************************
6:              * FileName:        main.c
7:              * Dependencies:    See INCLUDES section below
8:              * Processor:       PIC18
9:              * Compiler:        C18 3.45+
10:             * Company:         Microchip Technology, Inc.
11:             *
12:             * Software License Agreement
13:             *
14:             * The software supplied herewith by Microchip Technology Incorporated
15:             * (the "Company") for its PIC(R) Microcontroller is intended and
16:             * supplied to you, the Company's customer, for use solely and
17:             * exclusively on Microchip PICmicro Microcontroller products. The
18:             * software is owned by the Company and/or its supplier, and is
19:             * protected under applicable copyright laws. All rights are reserved.
20:             * Any use in violation of the foregoing restrictions may subject the
21:             * user to criminal sanctions under applicable laws, as well as to
22:             * civil liability for the breach of the terms and conditions of this
23:             * license.
24:             *
25:             * THIS SOFTWARE IS PROVIDED IN AN "AS IS"? CONDITION. NO WARRANTIES,
26:             * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:             * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:             * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:             * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:             *
32:             * File Version  Date		Comment
33:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
34:             * 1.0           06/19/2008 Original Version.  Adapted from
35:             *                          MCHPFSUSB v2.1 HID Bootloader
36:             *                          for PIC18F87J50 Family devices.
37:             * 2.9f          06/26/2012 Added PIC18F45K50 Family support.
38:             * 2.9j          06/10/2013 Added software entry point into bootloader
39:             *                          at 0x001C.  Some other enhancements.
40:             *                          Changed LED blink pattern to use only 1 LED and
41:             *                          consume less code space.  Added #define option to
42:             *                          disable LED blinking and I/O pushbutton entry
43:             *                          altogether.  See usbcfg.h settings.
44:             ********************************************************************/
45:            
46:            /*********************************************************************
47:            IMPORTANT NOTES: This code can be readily adapted for use with the 
48:            both the F and LF versions of the following devices:
49:            
50:            PIC18F4553/4458/2553/2458
51:            PIC18F4550/4455/2550/2455
52:            PIC18F4450/2450
53:            PIC18F14K50/13K50
54:            PIC18F45K50/25K50/24K50
55:            
56:            However, the default device that is currently selected in the project
57:            may not be the device you are interested.  To change the device:
58:            
59:            Replace the linker script with an appropriate version, and
60:            click "Configure --> Select Device" and select the proper
61:            microcontroller.  Also double check to verify that the io_cfg.h and
62:            usbcfg.h are properly configured to match your desired application
63:            platform.
64:            
65:            Verify that the configuration bits are set correctly for the intended
66:            target application, and fix any build errors that result from either
67:            the #error directives, or due to I/O pin count mismatch issues (such
68:            as when using a 28-pin device, but without making sufficient changes
69:            to the io_cfg.h file)
70:            
71:            This project needs to be built with the C18 compiler optimizations
72:            enabled, and using the Default storage class "Static" or the total
73:            code size will be too large to fit within the program memory
74:            range 0x000-0xFFF.  The default linker script included
75:            in the project has this range reserved for the use by the bootloader,
76:            but marks the rest of program memory as "PROTECTED".  If you try to
77:            build this project with the compiler optimizations turned off, or
78:            you try to modify some of this code, but add too much code to fit
79:            within the 0x000-0xFFF region, a linker error like that below may occur:
80:            
81:            Error - section '.code' can not fit the section. Section '.code' length=0x00000020
82:            To fix this error, either optimize the program to fit within 0x000-0xFFF
83:            (such as by turning on all compiler optimizations, and making sure the
84:            "default storage class" is set to "Static"), or modify the linker
85:            and vector remapping (as well as the application projects) to allow this
86:            bootloader to use more program memory.
87:            
88:            
89:            
90:            ----------------------Bootloader Entry------------------------------------------
91:            Entry into this bootloader firmware can be done by either of two possible
92:            ways:
93:            
94:            1.  I/O pin check at power up/after any reset.  and/or:
95:            2.  Software entry via absolute jump to address 0x001C.
96:            
97:            The I/O pin check method is the most rugged, since it does not require the 
98:            application firmware image to be intact (at all) to get into the bootloader
99:            mode.  However, software entry is also possible and may be more convenient
100:           in applications that do not have user exposed pushbuttons available.
101:           
102:           When the "application" image is executing, it may optionally jump into
103:           bootloader mode, by executing a _asm goto 0x001C _endasm instruction.  
104:           Before doing so however, the firwmare should configure the current
105:           clock settings to be compatible with USB module operation, in they
106:           are not already.  Once the goto 0x001C has been executed the USB device 
107:           will detach from the USB bus (if it was previously attached), and will 
108:           re-enumerate as a HID class device with a new VID/PID (adjustable via 
109:           usb_dsc.c settings), which can communicate with the associated
110:           USB host software that loads and programs the new .hex file.
111:           
112:           
113:           --------------------------------------------------------------------------------
114:           Anytime that an application implements flash self erase/write capability, 
115:           special care should be taken to make sure that the microcontroller is operated 
116:           within all datasheet ratings, especially those associated with voltage versus 
117:           frequency.
118:           
119:           Operating the device at too high of a frequency (for a given voltage, ex: by
120:           operating at 48MHz at 2.1V, while the device datasheet indicates some higher
121:           value such as 2.35V+ is requred) can cause unexpected code operation.  This
122:           could potentially allow inadvertent execution of bootloader or other self
123:           erase/write routines, causing corruption of the flash memory of the application.
124:           
125:           To avoid this, all applications that implement self erase/write capability 
126:           should make sure to prevent execution during overclocked/undervolted conditions.
127:           
128:           For this reason, enabling and using the microcontroller hardware Brown-out-Reset 
129:           feature is particularly recommended for applications using a bootloader.  If 
130:           BOR is not used, or the trip threshold is too low for the intended application 
131:           frequency, it is suggested to add extra code in the application to detect low 
132:           voltage conditions, and to intentionally clock switch to a lower frequency 
133:           (or put the device to sleep) during the low voltage condition.  Hardware
134:           modules such as the ADC, comparators, or the HLVD (high/low voltage detect)
135:           can often be used for this purpose.
136:           
137:           
138:           --------------------------------------------------------------------------------
139:           This bootloader supports reprogramming of the microcontroller configuration bits,
140:           however, it is strongly recommended never to do so, unless absolutely necessary.
141:           Reprogramming the config bits is potentially risky, since it requires that the
142:           new configuration bits be 100% compatible with USB operation (ex: oscillator
143:           settings, etc.).  If a .hex file with incorrect config bits is programmed
144:           into this device, it can render the bootloader inoperable.  Additionally,
145:           unexpected power failure or device detachment during the reprogramming of the
146:           config bits could result in unknown values getting stored in the config bits,
147:           which could "brick" the application.
148:           
149:           Normally, the application firmware project and this bootloader project should
150:           be configured to use/set the exact same configuration bit values.  Only one set
151:           of configuration bits actually exists in the microcontroller, and these values
152:           must be shared between the bootloader and application firmware.
153:           *******************************************************************************/
154:           
155:           
156:           
157:           
158:           
159:           
160:           
161:           /** I N C L U D E S **********************************************************/
162:           #include <p18cxxx.h>
163:           #include "typedefs.h"                   
164:           #include "usb.h"                         
165:           #include "io_cfg.h"                     
166:           #include "BootPIC18NonJ.h"
167:           #include "boot.h"
168:           
169:           /** C O N F I G U R A T I O N ************************************************/
170:           // Note: For a complete list of the available config pragmas and their values, 
171:           // see the compiler documentation, and/or click "Help --> Topics..." and then 
172:           // select "PIC18 Config Settings" in the Language Tools section.
173:           
174:           #if defined(PIC18F4550_PICDEM_FS_USB)		// Configuration bits for PICDEM FS USB Demo Board
175:            	#if defined(__18F4550) || defined(__18F4553)
176:                   #pragma config PLLDIV   = 5         // (20 MHz crystal on PICDEM FS USB board)
177:                   #pragma config CPUDIV   = OSC1_PLL2	
178:                   #pragma config USBDIV   = 2         // Clock source from 96MHz PLL/2
179:                   #pragma config FOSC     = HSPLL_HS
180:                   #pragma config FCMEN    = OFF
181:                   #pragma config IESO     = OFF
182:                   #pragma config PWRT     = OFF
183:                   #pragma config BOR      = ON
184:                   #pragma config BORV     = 3
185:                   #pragma config VREGEN   = ON		//USB Voltage Regulator
186:                   #pragma config WDT      = OFF
187:                   #pragma config WDTPS    = 32768
188:                   #pragma config MCLRE    = ON
189:                   #pragma config LPT1OSC  = OFF
190:                   #pragma config PBADEN   = OFF		//NOTE: modifying this value here won't have an effect
191:                   									//on the application.  See the top of the main() function.
192:                   									//By default the RB4 I/O pin is used to detect if the
193:                   									//firmware should enter the bootloader or the main application
194:                   									//firmware after a reset.  In order to do this, it needs to
195:                   									//configure RB4 as a digital input, thereby changing it from
196:                   									//the reset value according to this configuration bit.
197:           //      #pragma config CCP2MX   = ON
198:                   #pragma config STVREN   = ON
199:                   #pragma config LVP      = OFF
200:           //      #pragma config ICPRT    = OFF       // Dedicated In-Circuit Debug/Programming
201:                   #pragma config XINST    = OFF       // Extended Instruction Set
202:                   #pragma config CP0      = OFF
203:                   #pragma config CP1      = OFF
204:           //      #pragma config CP2      = OFF
205:           //      #pragma config CP3      = OFF
206:                   #pragma config CPB      = OFF
207:           //      #pragma config CPD      = OFF
208:                   #pragma config WRT0     = OFF
209:                   #pragma config WRT1     = OFF
210:           //      #pragma config WRT2     = OFF
211:           //      #pragma config WRT3     = OFF
212:                   #pragma config WRTB     = OFF       // Boot Block Write Protection
213:                   #pragma config WRTC     = OFF
214:           //      #pragma config WRTD     = OFF
215:                   #pragma config EBTR0    = OFF
216:                   #pragma config EBTR1    = OFF
217:           //      #pragma config EBTR2    = OFF
218:           //      #pragma config EBTR3    = OFF
219:                   #pragma config EBTRB    = OFF
220:           	#endif	//18F4550 and 18F4553
221:           
222:           
223:           #elif defined(PIC18F4550_PICDEM_FS_USB_K50)
224:                   #pragma config PLLSEL   = PLL3X     // 3X PLL multiplier selected
225:                   #pragma config CFGPLLEN = OFF       // PLL turned on during execution
226:                   #pragma config CPUDIV   = NOCLKDIV  // 1:1 mode (for 48MHz CPU)
227:                   #pragma config LS48MHZ  = SYS48X8   // Clock div / 8 in Low Speed USB mode
228:                   #pragma config FOSC     = INTOSCIO  // HFINTOSC selected at powerup, no clock out
229:                   #pragma config PCLKEN   = OFF       // Primary oscillator driver
230:                   #pragma config FCMEN    = OFF       // Fail safe clock monitor
231:                   #pragma config IESO     = OFF       // Internal/external switchover (two speed startup)
232:                   #pragma config nPWRTEN  = OFF       // Power up timer
233:                   #pragma config BOREN    = SBORDIS   // BOR enabled
234:                   #pragma config nLPBOR   = ON        // Low Power BOR
235:                   #pragma config WDTEN    = SWON      // Watchdog Timer controlled by SWDTEN
236:                   #pragma config WDTPS    = 32768     // WDT postscalar
237:                   #pragma config PBADEN   = OFF       // Port B Digital/Analog Powerup Behavior
238:                   #pragma config SDOMX    = RC7       // SDO function location
239:                   #pragma config LVP      = OFF       // Low voltage programming
240:                   #pragma config MCLRE    = ON        // MCLR function enabled (RE3 disabled)
241:                   #pragma config STVREN   = ON        // Stack overflow reset
242:                   //#pragma config ICPRT  = OFF       // Dedicated ICPORT program/debug pins enable
243:                   #pragma config XINST    = OFF       // Extended instruction set
244:           
245:           //If using the YOUR_BOARD hardware platform (see usbcfg.h), uncomment below and add pragmas
246:           //#elif defined(YOUR_BOARD)
247:           		//Add the configuration pragmas here for your hardware platform
248:           		//#pragma config ... 		= ...
249:           #elif defined(LOW_PIN_COUNT_USB_DEVELOPMENT_KIT)
250:                   #if !defined(__18F14K50) && !defined(__18F13K50) && !defined(__18LF14K50) && !defined(__18LF13K50)
251:                       #error Wrong processor selected for the selected demo board.
252:                   #endif
253:                   #pragma config CPUDIV = NOCLKDIV
254:                   #pragma config USBDIV = OFF
255:                   #pragma config FOSC   = HS
256:                   #pragma config PLLEN  = ON
257:                   #pragma config FCMEN  = OFF
258:                   #pragma config IESO   = OFF
259:                   #pragma config PWRTEN = OFF
260:                   #pragma config BOREN  = ON
261:                   #pragma config BORV   = 30
262:                   #pragma config WDTEN  = OFF
263:                   #pragma config WDTPS  = 32768
264:                   #pragma config MCLRE  = OFF
265:                   #pragma config HFOFST = OFF
266:                   #pragma config STVREN = ON
267:                   #pragma config LVP    = OFF
268:                   #pragma config XINST  = OFF
269:                   #pragma config BBSIZ  = OFF
270:                   #pragma config CP0    = OFF
271:                   #pragma config CP1    = OFF
272:                   #pragma config CPB    = OFF
273:                   #pragma config WRT0   = OFF
274:                   #pragma config WRT1   = OFF
275:                   #pragma config WRTB   = OFF
276:                   #pragma config WRTC   = OFF
277:                   #pragma config EBTR0  = OFF
278:                   #pragma config EBTR1  = OFF
279:                   #pragma config EBTRB  = OFF      
280:           #else
281:           	#error Not a supported board (yet), make sure the proper board is selected in usbcfg.h, and if so, set configuration bits in __FILE__, line __LINE__
282:           #endif
283:           
284:           /** V A R I A B L E S ********************************************************/
285:           //NOTE: You must not use initalized variables in this bootloader project.  This
286:           //firmware project does not rely on the standard C initializer, which is 
287:           //responsible for setting up initialized variables in RAM.  Therefore, all
288:           //variables will be non-initialized/random at start up.
289:           #pragma udata
290:           unsigned int uint_delay_counter;
291:           
292:           
293:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
294:           static void InitializeSystem(void);
295:           //void USBTasks(void);
296:           #define USBTasks()  {USBCheckBusStatus(); USBDriverService();}
297:           void ClearWatchdog(void);
298:           void DisableUSBandExecuteLongDelay(void);
299:           void LowVoltageCheck(void);
300:           
301:           #ifdef ENABLE_USB_LED_BLINK_STATUS
302:               void BlinkUSBStatus(void);
303:           #else
304:               #define BlinkUSBStatus()
305:           #endif
306:           
307:           
308:           
309:           /******************************************************************************
310:            * Function:        void UninitializedMain(void)
311:            *
312:            * PreCondition:    None
313:            *
314:            * Input:           None
315:            *
316:            * Output:          None
317:            *
318:            * Side Effects:    None
319:            *
320:            * Overview:        This is the main function for this bootloader mode firmware.
321:            *                  if execution gets to this function, it is assumed that we
322:            *                  want to stay in bootloader mode for now.
323:            *
324:            * Note:            If adding code to this function, make sure to add it only
325:            *                  after the C initializer like code at the top of this function.
326:            *****************************************************************************/
327:           
328:           #pragma code boot_entry_vector = BOOT_MAIN
329:           void BootMain(void)
330:           {
331:           	//NOTE: The c018.o file is not included in the linker script for this project.
332:           	//The C initialization code in the c018.c (comes with C18 compiler in the src directory)
333:           	//file is instead modified and included here manually.  This is done so as to provide
334:           	//a more convenient entry method into the bootloader firmware.  Ordinarily the _entry_scn
335:           	//program code section starts at 0x00 and is created by the code of c018.o.  However,
336:           	//the linker will not work if there is more than one section of code trying to occupy 0x00.
337:           	//Therefore, must not use the c018.o code, must instead manually include the useful code
338:           	//here instead.
339:           
340:               //Make sure interrupts are disabled for this code (could still be on,
341:               //if the application firmware jumped into the bootloader via software methods)
342:               INTCON = 0x00;  
0080  6AF2     CLRF INTCON, ACCESS
343:           
344:               // Initialize the C stack pointer, and other compiler managed items as normally done in the c018.c file.
345:           	_asm
346:               lfsr 1, _stack
0082  EE12     LFSR 1, 0x200
0084  F000     NOP
347:               lfsr 2, _stack
0086  EE22     LFSR 2, 0x200
0088  F000     NOP
348:               clrf TBLPTRU, 0 
008A  6AF8     CLRF TBLPTRU, ACCESS
349:           	_endasm
350:           
351:               //Clear the stack pointer, in case the user application jumped into 
352:               //bootloader mode with excessive junk on the call stack
353:               STKPTR = 0x00;  
008C  6AFC     CLRF STKPTR, ACCESS
354:           
355:           	// End of the important parts of the C initializer.  This bootloader firmware does not use
356:           	// any C initialized user variables (idata memory sections).  Therefore, the above is all
357:           	// the initialization that is required.
358:           
359:           
360:               //Check if the USB module is already enabled.  If so, disable it and wait 
361:               //~100ms+ (>1 second recommended if CDC application firmware on XP), to 
362:               //ensure that the host has a chance to see and process the USB device detach 
363:               //event.
364:               if(UCONbits.USBEN == 1)
008E  A66D     BTFSS UCON, 3, ACCESS
0090  D002     BRA 0x96
365:               {
366:                   //USB module was already on.  This is likely because the user applicaiton
367:                   //firmware jumped into this bootloader firmware using the absolute
368:                   //software entry method, without first turning off the USB module
369:                   DisableUSBandExecuteLongDelay(); 
0092  EC61     CALL 0x4C2, 0
0094  F002     NOP
370:               }    
371:           
372:           
373:               //Call other initialization code and (re)enable the USB module
374:               InitializeSystem();		//Some USB, I/O pins, and other initialization
0096  D811     RCALL InitializeSystem
375:               
376:               //Execute main loop
377:               while(1)
00B6  D7F0     BRA 0x98
378:               {
379:           		ClrWdt();
0098  0004     CLRWDT
380:           		
381:           		//Need to call USBTasks() periodically.  This function takes care of 
382:           		//processing non-USB application related USB packets (ex: "Chapter 9" 
383:           		//packets associated with USB enumeration)
384:           		USBTasks();             	    
009A  ECB2     CALL 0xD64, 0
009C  F006     NOP
009E  ECC6     CALL 0xD8C, 0
00A0  F006     NOP
385:           
386:           		BlinkUSBStatus();   //When enabled, blinks LEDs on the board, based on USB bus state
387:           		
388:           		LowVoltageCheck();  //Regularly monitor voltage to make sure it is sufficient
00A2  D818     RCALL LowVoltageCheck
389:           		                    //for safe operation at full frequency and for erase/write
390:           		                    //operations.		
391:           		
392:           		//Checks for and processes application related USB packets (assuming the
393:           		//USB bus is in the CONFIGURED_STATE, which is the only state where
394:           		//the host is allowed to send application related USB packets to the device.
395:           	    if((usb_device_state == CONFIGURED_STATE) && (UCONbits.SUSPND != 1))
00A4  0E06     MOVLW 0x6
00A6  0102     MOVLB 0x2
00A8  5DB4     SUBWF 0xB4, W, BANKED
00AA  E105     BNZ 0xB6
00AC  506D     MOVF UCON, W, ACCESS
00AE  0B02     ANDLW 0x2
00B0  E102     BNZ 0xB6
396:           	    {
397:            	       ProcessIO();   // This is where all the actual bootloader related data transfer/self programming takes place
00B2  EC75     CALL 0xEA, 0
00B4  F000     NOP
398:            	    }				  // see ProcessIO() function in the BootPIC[xxxx].c file.
399:               }//end while    
400:           }    
00B8  0012     RETURN 0
401:           
402:           
403:           /******************************************************************************
404:            * Function:        static void InitializeSystem(void)
405:            *
406:            * PreCondition:    None
407:            *
408:            * Input:           None
409:            *
410:            * Output:          None
411:            *
412:            * Side Effects:    None
413:            *
414:            * Overview:        InitializeSystem is a centralize initialization routine.
415:            *                  All required USB initialization routines are called from
416:            *                  here.
417:            *
418:            *                  User application initialization routine should also be
419:            *                  called from here.                  
420:            *
421:            * Note:            None
422:            *****************************************************************************/
423:           static void InitializeSystem(void)
424:           {
425:           //	The USB specifications require that USB peripheral devices must never source
426:           //	current onto the Vbus pin.  Additionally, USB peripherals should not source
427:           //	current on D+ or D- when the host/hub is not actively powering the Vbus line.
428:           //	When designing a self powered (as opposed to bus powered) USB peripheral
429:           //	device, the firmware should make sure not to turn on the USB module and D+
430:           //	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
431:           //	firmware needs some means to detect when Vbus is being powered by the host.
432:           //	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
433:           // 	can be used to detect when Vbus is high (host actively powering), or low
434:           //	(host is shut down or otherwise not supplying power).  The USB firmware
435:           // 	can then periodically poll this I/O pin to know when it is okay to turn on
436:           //	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
437:           //	peripheral device, it is not possible to source current on D+ or D- when the
438:           //	host is not actively providing power on Vbus. Therefore, implementing this
439:           //	bus sense feature is optional.  This firmware can be made to use this bus
440:           //	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
441:           //	usbcfg.h file.    
442:               #if defined(USE_USB_BUS_SENSE_IO)
443:                   tris_usb_bus_sense = INPUT_PIN; // See io_cfg.h
444:               #endif
445:           
446:           //	If the host PC sends a GetStatus (device) request, the firmware must respond
447:           //	and let the host know if the USB peripheral device is currently bus powered
448:           //	or self powered.  See chapter 9 in the official USB specifications for details
449:           //	regarding this request.  If the peripheral device is capable of being both
450:           //	self and bus powered, it should not return a hard coded value for this request.
451:           //	Instead, firmware should check if it is currently self or bus powered, and
452:           //	respond accordingly.  If the hardware has been configured like demonstrated
453:           //	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
454:           //	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2" 
455:           //	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
456:           //	has been defined in usbcfg.h, and that an appropriate I/O pin has been mapped
457:           //	to it in io_cfg.h.    
458:               #if defined(USE_SELF_POWER_SENSE_IO)
459:                   tris_self_power = INPUT_PIN;
460:               #endif
461:               
462:               //Initialize oscillator settings compatible with USB operation.  Note,
463:               //these may be application specific!
464:               #if defined(PIC18F4550_PICDEM_FS_USB_K50)
465:                   OSCTUNE = 0x80; //3X PLL ratio mode selected
466:                   OSCCON = 0x70;  //Switch to 16MHz HFINTOSC
467:                   OSCCON2 = 0x10; //Enable PLL, SOSC, PRI OSC drivers turned off
468:                   while(OSCCON2bits.PLLRDY != 1);   //Wait for PLL lock
469:                   ACTCON = 0x90;  //Enable active clock tuning for USB operation
470:                   //*((unsigned char*)0xFB5) = 0x90;  //Enable active clock tuning for USB operation
471:               #endif
472:               
473:               
474:               mInitializeUSBDriver();         // See usbdrv.h
00BA  0E14     MOVLW 0x14
00BC  6E6F     MOVWF UCFG, ACCESS
00BE  0102     MOVLB 0x2
00C0  6BB4     CLRF 0xB4, BANKED
00C2  0102     MOVLB 0x2
00C4  6BB5     CLRF 0xB5, BANKED
00C6  0102     MOVLB 0x2
00C8  6BB6     CLRF 0xB6, BANKED
475:               
476:               UserInit();                     // See user.c & .h
00CA  EC6C     CALL 0xD8, 0
00CC  F000     NOP
477:           
478:               mInitAllLEDs();			//Init them off.
00CE  908C     BCF LATD, 0, ACCESS
00D0  9095     BCF TRISD, 0, ACCESS
479:           
480:           }//end InitializeSystem
00D2  0012     RETURN 0
481:           
482:           
483:           //Check to make sure the VDD is sufficient for safe bootloader operation.
484:           //If the voltage is insufficient, code should be added to the below
485:           //function that clock switches to a low frequency internal oscillator and
486:           //puts the device to sleep, so as to avoid accidental operation under
487:           //"overclocked" (for a given voltage) conditions.  If BOR is enabled and is
488:           //set at a high enough level to trip before reaching a level insufficient for
489:           //maximum frequency operation, it may not be necessary to add additional checks
490:           //and the below warning can simply be commented out.
491:           void LowVoltageCheck(void)
492:           {
493:           	//12/9/2013 JDunne - BAH.. who needs LVD checks.... live dangerously..  (Seriously though, fix this for production)
494:               //#warning "Recommended to implement code here to check VDD.  Voltage detection can be done using ADC, HVLD, comparators, or other means."
495:           }    
00D4  0012     RETURN 0
496:           
497:               
498:           
499:           
500:           /******************************************************************************
501:            * Function:        void BlinkUSBStatus(void)
502:            *
503:            * PreCondition:    None
504:            *
505:            * Input:           None
506:            *
507:            * Output:          None
508:            *
509:            * Side Effects:    None
510:            *
511:            * Overview:        BlinkUSBStatus turns on and off LEDs corresponding to
512:            *                  the USB device state.
513:            *
514:            * Note:            mLED macros can be found in io_cfg.h
515:            *                  usb_device_state is declared in usbmmap.c and is modified
516:            *                  in usbdrv.c, usbctrltrf.c, and usb9.c
517:            *****************************************************************************/
518:           #ifdef ENABLE_USB_LED_BLINK_STATUS
519:           void BlinkUSBStatus(void)
520:           {
521:               static unsigned int led_count = 0;
522:           
523:               led_count--;
524:               if(led_count == 0)
525:               {
526:                   led_count = 19968U;  //Chosen instead of 20000, so that LSB is = 0x00 (more efficient to initialize)
527:                   if(usb_device_state < CONFIGURED_STATE)
528:                   {
529:                       mLED_1_On();
530:                   } 
531:                   else
532:                   {
533:                       mLED_1_Toggle();
534:                   }    
535:               }    
536:           }//end BlinkUSBStatus
537:           #endif //#ifdef ENABLE_USB_LED_BLINK_STATUS
538:           
539:           
540:           /** EOF main.c ***************************************************************/
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/hid.c  -------------------------------------------------
1:             /*********************************************************************
2:              *
3:              *             Microchip USB C18 Firmware -  HID Version 1.0
4:              *
5:              *********************************************************************
6:              * FileName:        hid.c
7:              * Dependencies:    See INCLUDES section below
8:              * Processor:       PIC18
9:              * Compiler:        C18 2.30.01+
10:             * Company:         Microchip Technology, Inc.
11:             *
12:             * Software License Agreement
13:             *
14:             * The software supplied herewith by Microchip Technology Incorporated
15:             * (the ?Company?) for its PICmicro Microcontroller is intended and
16:             * supplied to you, the Company?s customer, for use solely and
17:             * exclusively on Microchip PICmicro Microcontroller products. The
18:             * software is owned by the Company and/or its supplier, and is
19:             * protected under applicable copyright laws. All rights are reserved.
20:             * Any use in violation of the foregoing restrictions may subject the
21:             * user to criminal sanctions under applicable laws, as well as to
22:             * civil liability for the breach of the terms and conditions of this
23:             * license.
24:             *
25:             * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
26:             * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
27:             * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
28:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
29:             * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
30:             * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
31:             *
32:             * Author               Date        Comment
33:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
34:             * Rawin Rojvanit       11/19/04    Original.
35:             ********************************************************************/
36:            
37:            /** I N C L U D E S **********************************************************/
38:            #include <p18cxxx.h>
39:            #include "typedefs.h"
40:            #include "usb.h"
41:            
42:            #ifdef USB_USE_HID
43:            
44:            /** V A R I A B L E S ********************************************************/
45:            #pragma udata
46:            byte idle_rate;
47:            byte active_protocol;               // [0] Boot Protocol [1] Report Protocol
48:            byte hid_rpt_rx_len;
49:            
50:            /** P R I V A T E  P R O T O T Y P E S ***************************************/
51:            void HIDGetReportHandler(void);
52:            void HIDSetReportHandler(void);
53:            
54:            /** D E C L A R A T I O N S **************************************************/
55:            #pragma code
56:            
57:            /** C L A S S  S P E C I F I C  R E Q ****************************************/
58:            /******************************************************************************
59:             * Function:        void USBCheckHIDRequest(void)
60:             *
61:             * PreCondition:    None
62:             *
63:             * Input:           None
64:             *
65:             * Output:          None
66:             *
67:             * Side Effects:    None
68:             *
69:             * Overview:        This routine checks the setup data packet to see if it
70:             *                  knows how to handle it
71:             *
72:             * Note:            None
73:             *****************************************************************************/
74:            void USBCheckHIDRequest(void)
75:            {
76:                if(SetupPkt.Recipient != RCPT_INTF) return;
0BBA  0104     MOVLB 0x4
0BBC  5110     MOVF 0x10, W, BANKED
0BBE  0B1F     ANDLW 0x1F
0BC0  0801     SUBLW 0x1
0BC2  E001     BZ 0xBC6
0BC4  0012     RETURN 0
77:                if(SetupPkt.bIntfID != HID_INTF_ID) return;
0BC6  5114     MOVF 0x14, W, BANKED
0BC8  E001     BZ 0xBCC
0BCA  0012     RETURN 0
78:                
79:                /*
80:                 * There are two standard requests that hid.c may support.
81:                 * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
82:                 * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
83:                 */
84:                if(SetupPkt.bRequest == GET_DSC)
0BCC  0E06     MOVLW 0x6
0BCE  5D11     SUBWF 0x11, W, BANKED
0BD0  E124     BNZ 0xC1A
85:                {
86:                    switch(SetupPkt.bDscType)
0BD2  5113     MOVF 0x13, W, BANKED
0BD4  0A23     XORLW 0x23
0BD6  E01F     BZ 0xC16
0BD8  0A01     XORLW 0x1
0BDA  E00D     BZ 0xBF6
0BDC  0A03     XORLW 0x3
0BDE  E11B     BNZ 0xC16
87:                    {
88:                        case DSC_HID:
89:                            ctrl_trf_session_owner = MUID_HID;
0BE0  D8BD     RCALL __pa_0
90:                            mUSBGetHIDDscAdr(pSrc.bRom);        // See usbcfg.h
0BE2  0102     MOVLB 0x2
0BE4  05B6     DECF 0xB6, W, BANKED
0BE6  E105     BNZ 0xBF2
0BE8  0102     MOVLB 0x2
0BEA  0EE0     MOVLW 0xE0
0BEC  6FA2     MOVWF 0xA2, BANKED
0BEE  0E0E     MOVLW 0xE
0BF0  6FA3     MOVWF 0xA3, BANKED
91:                            wCount._word = sizeof(USB_HID_DSC);
0BF2  0E09     MOVLW 0x9
92:                            break;
0BF4  D00D     BRA 0xC10
93:                        case DSC_RPT:
94:                            ctrl_trf_session_owner = MUID_HID;
0BF6  D8B2     RCALL __pa_0
0D5C  0102     MOVLB 0x2
0D5E  0E02     MOVLW 0x2
0D60  6FA1     MOVWF PacketFromPC, BANKED
0D62  0012     RETURN 0
95:                            mUSBGetHIDRptDscAdr(pSrc.bRom);     // See usbcfg.h
0BF8  0102     MOVLB 0x2
0BFA  05B6     DECF 0xB6, W, BANKED
0BFC  E105     BNZ 0xC08
0BFE  0102     MOVLB 0x2
0C00  0E55     MOVLW 0x55
0C02  6FA2     MOVWF 0xA2, BANKED
0C04  0E0F     MOVLW 0xF
0C06  6FA3     MOVWF 0xA3, BANKED
96:                            mUSBGetHIDRptDscSize(wCount._word); // See usbcfg.h
0C08  0102     MOVLB 0x2
0C0A  05B6     DECF 0xB6, W, BANKED
0C0C  E104     BNZ 0xC16
0C0E  0E1D     MOVLW 0x1D
0C10  0102     MOVLB 0x2
0C12  6FA6     MOVWF 0xA6, BANKED
0C14  6BA7     CLRF 0xA7, BANKED
97:                            break;
98:                        case DSC_PHY:
99:                            // ctrl_trf_session_owner = MUID_HID;
100:                           break;
101:                   }//end switch(SetupPkt.bDscType)
102:                   usb_stat.ctrl_trf_mem = _ROM;
0C16  0102     MOVLB 0x2
0C18  83B5     BSF 0xB5, 1, BANKED
103:               }//end if(SetupPkt.bRequest == GET_DSC)
104:               
105:               if(SetupPkt.RequestType != CLASS) return;
0C1A  0104     MOVLB 0x4
0C1C  5110     MOVF 0x10, W, BANKED
0C1E  0B60     ANDLW 0x60
0C20  42E8     RRNCF WREG, F, ACCESS
0C22  42E8     RRNCF WREG, F, ACCESS
0C24  42E8     RRNCF WREG, F, ACCESS
0C26  42E8     RRNCF WREG, F, ACCESS
0C28  42E8     RRNCF WREG, F, ACCESS
0C2A  0801     SUBLW 0x1
0C2C  E001     BZ 0xC30
0C2E  0012     RETURN 0
106:               switch(SetupPkt.bRequest)
0C30  5111     MOVF 0x11, W, BANKED
0C32  0A0B     XORLW 0xB
0C34  E025     BZ 0xC80
0C36  0A08     XORLW 0x8
0C38  E017     BZ 0xC68
0C3A  0A09     XORLW 0x9
0C3C  E011     BZ 0xC60
0C3E  0A08     XORLW 0x8
0C40  E009     BZ 0xC54
0C42  0A0B     XORLW 0xB
0C44  E005     BZ 0xC50
0C46  0A08     XORLW 0x8
0C48  E001     BZ 0xC4C
0C4A  0012     RETURN 0
107:               {
108:                   case GET_REPORT:
109:                       HIDGetReportHandler();
0C4C  EF44     GOTO 0xC88
0C4E  F006     NOP
110:                       break;
111:                   case SET_REPORT:
112:                       HIDSetReportHandler();            
0C50  EF45     GOTO 0xC8A
0C52  F006     NOP
113:                       break;
114:                   case GET_IDLE:
115:                       ctrl_trf_session_owner = MUID_HID;
0C54  D883     RCALL __pa_0
116:                       pSrc.bRam = (byte*)&idle_rate;      // Set source
0C56  0102     MOVLB 0x2
0C58  0EF5     MOVLW 0xF5
0C5A  6FA2     MOVWF 0xA2, BANKED
0C5C  0E00     MOVLW 0x0
117:                       usb_stat.ctrl_trf_mem = _RAM;       // Set memory type
118:                       LSB(wCount) = 1;                    // Set data count
119:                       break;
0C5E  D009     BRA 0xC72
120:                   case SET_IDLE:
121:                       ctrl_trf_session_owner = MUID_HID;
0C60  D87D     RCALL __pa_0
122:                       idle_rate = MSB(SetupPkt.W_Value);
0C62  C413     MOVFF 0x413, idle_rate
0C64  F0F5     NOP
123:                       break;
0C66  0012     RETURN 0
124:                   case GET_PROTOCOL:
125:                       ctrl_trf_session_owner = MUID_HID;
0C68  D879     RCALL __pa_0
126:                       pSrc.bRam = (byte*)&active_protocol;// Set source
0C6A  0102     MOVLB 0x2
0C6C  0EF6     MOVLW 0xF6
0C6E  6FA2     MOVWF 0xA2, BANKED
0C70  0E00     MOVLW 0x0
0C72  6FA3     MOVWF 0xA3, BANKED
127:                       usb_stat.ctrl_trf_mem = _RAM;       // Set memory type
0C74  0102     MOVLB 0x2
0C76  93B5     BCF 0xB5, 1, BANKED
128:                       LSB(wCount) = 1;                    // Set data count
0C78  0102     MOVLB 0x2
0C7A  0E01     MOVLW 0x1
0C7C  6FA6     MOVWF 0xA6, BANKED
129:                       break;
0C7E  0012     RETURN 0
130:                   case SET_PROTOCOL:
131:                       ctrl_trf_session_owner = MUID_HID;
0C80  D86D     RCALL __pa_0
132:                       active_protocol = LSB(SetupPkt.W_Value);
0C82  C412     MOVFF 0x412, active_protocol
0C84  F0F6     NOP
133:                       break;
134:               }//end switch(SetupPkt.bRequest)
135:           
136:           }//end USBCheckHIDRequest
0C86  0012     RETURN 0
137:           
138:           void HIDGetReportHandler(void)
139:           {
140:               // ctrl_trf_session_owner = MUID_HID;
141:           }//end HIDGetReportHandler
0C88  0012     RETURN 0
142:           
143:           void HIDSetReportHandler(void)
144:           {
145:               // ctrl_trf_session_owner = MUID_HID;
146:               // pDst.bRam = (byte*)&hid_report_out;
147:           }//end HIDSetReportHandler
0C8A  0012     RETURN 0
148:           
149:           /** U S E R  A P I ***********************************************************/
150:           
151:           /******************************************************************************
152:            * Function:        void HIDInitEP(void)
153:            *
154:            * PreCondition:    None
155:            *
156:            * Input:           None
157:            *
158:            * Output:          None
159:            *
160:            * Side Effects:    None
161:            *
162:            * Overview:        HIDInitEP initializes HID endpoints, buffer descriptors,
163:            *                  internal state-machine, and variables.
164:            *                  It should be called after the USB host has sent out a
165:            *                  SET_CONFIGURATION request.
166:            *                  See USBStdSetCfgHandler() in usb9.c for examples.
167:            *
168:            * Note:            None
169:            *****************************************************************************/
170:           void HIDInitEP(void)
171:           {   
172:               hid_rpt_rx_len =0;
0C8C  0100     MOVLB 0x0
0C8E  6BF7     CLRF hid_rpt_rx_len, BANKED
173:               
174:               HID_UEP = EP_OUT_IN|HSHK_EN;                // Enable 2 data pipes
0C90  0E1E     MOVLW 0x1E
0C92  6E71     MOVWF UEP1, ACCESS
175:               
176:               HID_BD_OUT.Cnt = sizeof(hid_report_out);    // Set buffer size
0C94  0104     MOVLB 0x4
0C96  0E40     MOVLW 0x40
0C98  6F09     MOVWF 0x9, BANKED
177:               HID_BD_OUT.ADR = (byte*)&hid_report_out;    // Set buffer address
0C9A  0E20     MOVLW 0x20
0C9C  6F0A     MOVWF 0xA, BANKED
0C9E  0E04     MOVLW 0x4
0CA0  6F0B     MOVWF 0xB, BANKED
178:               HID_BD_OUT.Stat._byte = _USIE|_DAT0|_DTSEN; // Set status
0CA2  0E88     MOVLW 0x88
0CA4  6F08     MOVWF 0x8, BANKED
179:           
180:               /*
181:                * Do not have to init Cnt of IN pipes here.
182:                * Reason:  Number of bytes to send to the host
183:                *          varies from one transaction to
184:                *          another. Cnt should equal the exact
185:                *          number of bytes to transmit for
186:                *          a given IN transaction.
187:                *          This number of bytes will only
188:                *          be known right before the data is
189:                *          sent.
190:                */
191:               HID_BD_IN.ADR = (byte*)&hid_report_in;      // Set buffer address
0CA6  0104     MOVLB 0x4
0CA8  0E60     MOVLW 0x60
0CAA  6F0E     MOVWF 0xE, BANKED
0CAC  0E04     MOVLW 0x4
0CAE  6F0F     MOVWF 0xF, BANKED
192:               HID_BD_IN.Stat._byte = _UCPU|_DAT1;         // Set status
0CB0  0E40     MOVLW 0x40
0CB2  6F0C     MOVWF 0xC, BANKED
193:           
194:           }//end HIDInitEP
0CB4  0012     RETURN 0
195:           
196:           /******************************************************************************
197:            * Function:        void HIDTxReport(char *buffer, byte len)
198:            *
199:            * PreCondition:    mHIDTxIsBusy() must return false.
200:            *
201:            *                  Value of 'len' must be equal to or smaller than
202:            *                  HID_INT_IN_EP_SIZE
203:            *                  For an interrupt endpoint, the largest buffer size is
204:            *                  64 bytes.
205:            *
206:            * Input:           buffer  : Pointer to the starting location of data bytes
207:            *                  len     : Number of bytes to be transferred
208:            *
209:            * Output:          None
210:            *
211:            * Side Effects:    None
212:            *
213:            * Overview:        Use this macro to transfer data located in data memory.
214:            *
215:            *                  Remember: mHIDTxIsBusy() must return false before user
216:            *                  can call this function.
217:            *                  Unexpected behavior will occur if this function is called
218:            *                  when mHIDTxIsBusy() == 0
219:            *
220:            *                  Typical Usage:
221:            *                  if(!mHIDTxIsBusy())
222:            *                      HIDTxReport(buffer, 3);
223:            *
224:            * Note:            None
225:            *****************************************************************************/
226:           void HIDTxReport(char *buffer, byte len)
227:           {
228:           	byte i;
229:           	
230:               /*
231:                * Value of len should be equal to or smaller than HID_INT_IN_EP_SIZE.
232:                * This check forces the value of len to meet the precondition.
233:                */
234:           	if(len > HID_INT_IN_EP_SIZE)
0CB6  0100     MOVLB 0x0
0CB8  51FA     MOVF len, W, BANKED
0CBA  0840     SUBLW 0x40
0CBC  E202     BC 0xCC2
235:           	    len = HID_INT_IN_EP_SIZE;
0CBE  0E40     MOVLW 0x40
0CC0  6FFA     MOVWF len, BANKED
236:           
237:              /*
238:               * Copy data from user's buffer to dual-ram buffer
239:               */
240:               for (i = 0; i < len; i++)
0CC2  6BFB     CLRF i, BANKED
0CC4  51FA     MOVF len, W, BANKED
0CC6  5DFB     SUBWF i, W, BANKED
0CC8  E213     BC 0xCF0
0CEC  2BFB     INCF i, F, BANKED
0CEE  D7EA     BRA 0xCC4
241:               	hid_report_in[i] = buffer[i];
0CCA  51FB     MOVF i, W, BANKED
0CCC  6AEA     CLRF FSR0H, ACCESS
0CCE  25F8     ADDWF buffer, W, BANKED
0CD0  6EE9     MOVWF FSR0L, ACCESS
0CD2  51F9     MOVF 0xF9, W, BANKED
0CD4  22EA     ADDWFC FSR0H, F, ACCESS
0CD6  50EF     MOVF INDF0, W, ACCESS
0CD8  6EE6     MOVWF POSTINC1, ACCESS
0CDA  51FB     MOVF i, W, BANKED
0CDC  6AEA     CLRF FSR0H, ACCESS
0CDE  0F60     ADDLW 0x60
0CE0  6EE9     MOVWF FSR0L, ACCESS
0CE2  0E04     MOVLW 0x4
0CE4  22EA     ADDWFC FSR0H, F, ACCESS
0CE6  52E5     MOVF POSTDEC1, F, ACCESS
0CE8  50E7     MOVF INDF1, W, ACCESS
0CEA  6EEF     MOVWF INDF0, ACCESS
242:           
243:               HID_BD_IN.Cnt = len;
0CF0  C0FA     MOVFF len, 0x40D
0CF2  F40D     NOP
244:               mUSBBufferReady(HID_BD_IN);
0CF4  0E40     MOVLW 0x40
0CF6  0104     MOVLB 0x4
0CF8  170C     ANDWF 0xC, F, BANKED
0CFA  7D0C     BTG 0xC, 6, BANKED
0CFC  0E88     MOVLW 0x88
0CFE  130C     IORWF 0xC, F, BANKED
245:           
246:           }//end HIDTxReport
0D00  0012     RETURN 0
247:           
248:           /******************************************************************************
249:            * Function:        byte HIDRxReport(char *buffer, byte len)
250:            *
251:            * PreCondition:    Value of input argument 'len' should be smaller than the
252:            *                  maximum endpoint size responsible for receiving report
253:            *                  data from USB host for HID class.
254:            *                  Input argument 'buffer' should point to a buffer area that
255:            *                  is bigger or equal to the size specified by 'len'.
256:            *
257:            * Input:           buffer  : Pointer to where received bytes are to be stored
258:            *                  len     : The number of bytes expected.
259:            *
260:            * Output:          The number of bytes copied to buffer.
261:            *
262:            * Side Effects:    Publicly accessible variable hid_rpt_rx_len is updated
263:            *                  with the number of bytes copied to buffer.
264:            *                  Once HIDRxReport is called, subsequent retrieval of
265:            *                  hid_rpt_rx_len can be done by calling macro
266:            *                  mHIDGetRptRxLength().
267:            *
268:            * Overview:        HIDRxReport copies a string of bytes received through
269:            *                  USB HID OUT endpoint to a user's specified location. 
270:            *                  It is a non-blocking function. It does not wait
271:            *                  for data if there is no data available. Instead it returns
272:            *                  '0' to notify the caller that there is no data available.
273:            *
274:            * Note:            If the actual number of bytes received is larger than the
275:            *                  number of bytes expected (len), only the expected number
276:            *                  of bytes specified will be copied to buffer.
277:            *                  If the actual number of bytes received is smaller than the
278:            *                  number of bytes expected (len), only the actual number
279:            *                  of bytes received will be copied to buffer.
280:            *****************************************************************************/
281:           byte HIDRxReport(char *buffer, byte len)
282:           {
283:               hid_rpt_rx_len = 0;
0D02  0100     MOVLB 0x0
0D04  6BF7     CLRF hid_rpt_rx_len, BANKED
284:               
285:               if(!mHIDRxIsBusy())
0D06  0104     MOVLB 0x4
0D08  BF08     BTFSC 0x8, 7, BANKED
0D0A  D025     BRA 0xD56
286:               {
287:                   /*
288:                    * Adjust the expected number of bytes to equal
289:                    * the actual number of bytes received.
290:                    */
291:                   if(len > HID_BD_OUT.Cnt)
0D0C  5109     MOVF 0x9, W, BANKED
0D0E  0100     MOVLB 0x0
0D10  80D8     BSF STATUS, 0, ACCESS
0D12  55FE     SUBFWB len, W, BANKED
0D14  E202     BC 0xD1A
292:                       len = HID_BD_OUT.Cnt;
0D16  C409     MOVFF 0x409, len
0D18  F0FE     NOP
293:                   
294:                   /*
295:                    * Copy data from dual-ram buffer to user's buffer
296:                    */
297:                   for(hid_rpt_rx_len = 0; hid_rpt_rx_len < len; hid_rpt_rx_len++)
0D1A  6BF7     CLRF hid_rpt_rx_len, BANKED
0D1C  51FE     MOVF len, W, BANKED
0D1E  5DF7     SUBWF hid_rpt_rx_len, W, BANKED
0D20  E213     BC 0xD48
0D44  2BF7     INCF hid_rpt_rx_len, F, BANKED
0D46  D7EA     BRA 0xD1C
298:                       buffer[hid_rpt_rx_len] = hid_report_out[hid_rpt_rx_len];
0D22  51F7     MOVF hid_rpt_rx_len, W, BANKED
0D24  6AEA     CLRF FSR0H, ACCESS
0D26  0F20     ADDLW 0x20
0D28  6EE9     MOVWF FSR0L, ACCESS
0D2A  0E04     MOVLW 0x4
0D2C  22EA     ADDWFC FSR0H, F, ACCESS
0D2E  50EF     MOVF INDF0, W, ACCESS
0D30  6EE6     MOVWF POSTINC1, ACCESS
0D32  51F7     MOVF hid_rpt_rx_len, W, BANKED
0D34  6AEA     CLRF FSR0H, ACCESS
0D36  25FC     ADDWF buffer, W, BANKED
0D38  6EE9     MOVWF FSR0L, ACCESS
0D3A  51FD     MOVF 0xFD, W, BANKED
0D3C  22EA     ADDWFC FSR0H, F, ACCESS
0D3E  52E5     MOVF POSTDEC1, F, ACCESS
0D40  50E7     MOVF INDF1, W, ACCESS
0D42  6EEF     MOVWF INDF0, ACCESS
299:           
300:                   /*
301:                    * Prepare dual-ram buffer for next OUT transaction
302:                    */
303:                   HID_BD_OUT.Cnt = sizeof(hid_report_out);
0D48  0104     MOVLB 0x4
0D4A  0E40     MOVLW 0x40
0D4C  6F09     MOVWF 0x9, BANKED
304:                   mUSBBufferReady(HID_BD_OUT);
0D4E  1708     ANDWF 0x8, F, BANKED
0D50  7D08     BTG 0x8, 6, BANKED
0D52  0E88     MOVLW 0x88
0D54  1308     IORWF 0x8, F, BANKED
305:               }//end if
306:               
307:               return hid_rpt_rx_len;
0D56  0100     MOVLB 0x0
0D58  51F7     MOVF hid_rpt_rx_len, W, BANKED
308:               
309:           }//end HIDRxReport
0D5A  0012     RETURN 0
310:           
311:           #endif //def USB_USE_HID
312:           
313:           /** EOF hid.c ***************************************************************/
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/UserAppCode.c  -----------------------------------------
1:             //#######################################################################
2:             /**
3:             * @file UserAppCode.c
4:             * This is just a dummy file that only exists in the bootloader project.
5:             * This file is a placeholder for the user app.
6:             *
7:             * @author Joe Dunne
8:             * @date 12/9/13
9:             * @brief User app placeholder
10:            */
11:            //#######################################################################
12:            
13:            
14:            
15:            
16:            /** I N C L U D E S **********************************************************/
17:            #include <p18cxxx.h>
18:            #include "typedefs.h"
19:            #include "usb.h"
20:            #include "io_cfg.h"
21:            #include "BootPIC18NonJ.h"
22:            #include "boot.h"
23:            
24:            
25:            
26:            //Placeholder code at address 0x1000 (the start of the non-bootloader firmware space)
27:            //This gets overwritten when a real hex file gets programmed by the bootloader.
28:            //If however no hex file has been programmed (yet), might as well stay in the
29:            //bootloader firmware, even if the pushbutton or software entry attempt has not
30:            //been made yet, since the device is still blank.
31:            #pragma code user_app_vector = REMAPPED_APPLICATION_RESET_VECTOR
32:            void userApp(void)
33:            {
34:            	_asm goto BOOTLOADER_ABSOLUTE_ENTRY_ADDRESS _endasm 	//Goes into the BootMain() section which force bootloader mode operation
1000  EF0E     GOTO 0x1C
1002  F000     NOP
35:            }
1004  0012     RETURN 0
36:            
37:            //Initialize with a valid application signature already loaded to allow the code to run at startup rather than jumping to bootload mode.
38:            #pragma	romdata	app_signature=APP_SIGNATURE_ADDRESS
39:            rom const unsigned short app_sig = {APP_SIGNATURE_VALUE};
40:            
41:            #pragma	romdata	app_version=APP_VERSION_ADDRESS
42:            rom const unsigned short app_ver = {APP_VERSION};
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/BootUserStartup.c  -------------------------------------
1:             //#######################################################################
2:             /**
3:             * @file BootUserStartup.c
4:             * This is the startup code that calls either the user or bootloader application
5:             * depending if app code is viable.
6:             *
7:             * @author Joe Dunne
8:             * @date 12/9/13
9:             * @brief Bootloader User Startup
10:            */
11:            //#######################################################################
12:            
13:            
14:            
15:            
16:            /** I N C L U D E S **********************************************************/
17:            #include <p18cxxx.h>
18:            #include "typedefs.h"
19:            #include "usb.h"
20:            //#include "io_cfg.h"
21:            //#include "BootPIC18NonJ.h"
22:            #include "boot.h"
23:            
24:            
25:            /** Prototypes **********************************************************/
26:            void UninitializedMain(void);
27:            void BootMain(void);
28:            
29:            
30:            //Never comment this out.  If you do, you won't be able to recover if the user
31:            //unplugs the USB cable (or power is lost) during an erase/program sequence,
32:            //unless you rely on the I/O pin check entry method.  The only reason ever to
33:            //comment this out, is if you are trying to use this bootloader firmware with
34:            //an old bootloader PC application that does not have knowledge of the v1.01
35:            //and newer command set (with QUERY_EXTENDED_INFO and SIGN_FLASH commands).
36:            //However, a better solution in such a case, is to upgrade to use a newer PC
37:            //application to do the bootloading.
38:            #define ENABLE_FLASH_SIGNATURE_VERIFICATION
39:            
40:            
41:            /****** Program memory vectors, constants, and application remapping*********************/
42:            //Be careful if modifying the below code.  The below code is absolute address sensitive.
43:            #pragma code true_entry_scn=0x000000		//Reset vector is at 0x00.  Device begins executing code from 0x00 after a reset or POR event
44:            void true_entry (void)
45:            {
46:                _asm goto UninitializedMain _endasm
0000  EF11     GOTO 0x22
0002  F000     NOP
47:            }
0004  0012     RETURN 0
48:            
49:            //The hardware high priority interrupt vector.  This bootloader firmware does
50:            //not use interrupts at all.  If an interrupt occurs, it is due to application
51:            //mode operation.  Therefore, if an interrupt occurs, we should just jump to
52:            //the remapped address (that resides inside hte application image firmware space).
53:            #pragma code high_vector=0x08
54:            void interrupt_at_high_vector(void)
55:            {
56:                _asm goto REMAPPED_APPLICATION_HIGH_ISR_VECTOR _endasm
0008  EF04     GOTO 0x1008
000A  F008     NOP
57:            }
000C  0012     RETURN 0
58:            
59:            //The hardware high priority interrupt vector
60:            #pragma code low_vector=0x18
61:            void interrupt_at_low_vector(void)
62:            {
63:                //Do not change the code in this function.  Doing so will shift the
64:                //addresses of things around, which will prevent proper operation.
65:                _asm goto REMAPPED_APPLICATION_LOW_ISR_VECTOR _endasm    //This goto is located at 0x0018.  This "goto" instruction takes 4 bytes of prog memory.
0018  EF0C     GOTO 0x1018
001A  F008     NOP
66:                _asm goto BOOT_MAIN _endasm  //This goto is located at address 0x001C.  This is the absolute
001C  EF40     GOTO 0x80
001E  F000     NOP
67:                                            //entry vector value for jumping from the app into the bootloader
68:                                            //mode via software.  This goto is normally unreachable,
69:                                            //unless the application firmware executes an
70:                                            //intentional _asm goto 0x001C _endasm ("#asm goto 0x001C #endasm" if using XC8 compiler).
71:            }
0020  0012     RETURN 0
72:            
73:            
74:            
75:            
76:            /** D E C L A R A T I O N S **************************************************/
77:            #pragma code	BOOTSTARTUP
78:            /******************************************************************************
79:             * Function:        void UninitializedMain(void)
80:             *
81:             * PreCondition:    None
82:             *
83:             * Input:           None
84:             *
85:             * Output:          None
86:             *
87:             * Side Effects:    None
88:             *
89:             * Overview:        This is the first code that executes during boot up of
90:             *                  the microcontroller.  This code checks to see if execution
91:             *                  should stay in the "bootloader" mode, or if it should jump
92:             *                  into the "application" (non-bootloder) execution mode.
93:             *                  No other unrelated code should be added to this function.
94:             *
95:             * Note:            THIS FUNCTION EXECUTES PRIOR TO INITIALIZATION OF THE C
96:             *                  STACK.  NO C INITIALIZATION OF STATIC VARIABLES OR RESOURCES
97:             *                  WILL OCCUR, PRIOR TO EXECUTING THIS FUNCTION.  THEREFORE,
98:             *                  THE CODE IN THIS FUNCTION MUST NOT CALL OTHER FUNCTIONS OR
99:             *                  PERFORM ANY OPERATIONS THAT WILL REQUIRE C INITIALIZED
100:            *                  BEHAVIOR.
101:            *****************************************************************************/
102:           void UninitializedMain(void)
103:           {
104:               //Assuming the I/O pin check entry method is enabled, check the I/O pin value
105:               //to see if we should stay in bootloader mode, or jump to normal applicaiton
106:               //execution mode.
107:           
108:           
109:           	//TODO: Modify code here to check for I/O pin to allow entry into bootload mode!!
110:           
111:           
112:           	//Need to make sure the I/O pin is configured for digital mode so we
113:           	//can sense the digital level on the input pin.
114:           	//mInitSwitch2();
115:           
116:           	//Check Bootload Mode Entry Condition from the I/O pin (ex: place a
117:           	//pushbutton and pull up resistor on the pin)
118:           	if(0 /*sw2 == 1*/)
0022  D002     BRA 0x28
119:           	{
120:           		//If we get to here, the user is not pressing the pushbutton.  We
121:           		//should default to jumping into application run mode in this case.
122:           		//Restore default "reset" value of registers we may have modified temporarily.
123:           		//mDeInitSwitch2();
124:           
125:           		//Before going to application image however, make sure the image
126:           		//is properly signed and is intact.
127:           		goto DoFlashSignatureCheck;
0024  D003     BRA 0x2C
128:           	}
129:           	else
0026  D002     BRA 0x2C
130:           	{
131:           		//User is pressing the pushbutton.  We should stay in bootloader mode
132:           		_asm goto BOOT_MAIN _endasm
0028  EF40     GOTO 0x80
002A  F000     NOP
133:           	}
134:           
135:           DoFlashSignatureCheck:
136:               //Check if the application region flash signature is valid
137:               #ifdef ENABLE_FLASH_SIGNATURE_VERIFICATION
138:                   if(*(rom unsigned int*)APP_SIGNATURE_ADDRESS == APP_SIGNATURE_VALUE)
002C  0E06     MOVLW 0x6
002E  6EF6     MOVWF TBLPTRL, ACCESS
0030  0E10     MOVLW 0x10
0032  6EF7     MOVWF TBLPTRH, ACCESS
0034  0009     TBLRD*+
0036  CFF5     MOVFF TABLAT, __tmp_0
0038  F000     NOP
003A  0008     TBLRD*
003C  CFF5     MOVFF TABLAT, 0x1
003E  F001     NOP
0040  0E0D     MOVLW 0xD
0042  1800     XORWF __tmp_0, W, ACCESS
0044  E102     BNZ 0x4A
0046  0E60     MOVLW 0x60
0048  1801     XORWF 0x1, W, ACCESS
004A  E102     BNZ 0x50
139:                   {
140:                       //The flash signature was valid, implying the previous
141:                       //erase/program/verify operation was a success.
142:           
143:                       //Go ahead and jump out of bootloader mode into the application run mode
144:               		_asm goto REMAPPED_APPLICATION_RESET_VECTOR _endasm
004C  EF00     GOTO 0x1000
004E  F008     NOP
145:                   }
146:                   //else the application image is missing or corrupt.  In this case, we
147:                   //need to stay in the bootloader mode, so the user has the ability to
148:                   //try (again) to re-program a valid application image into the device.
149:           
150:               	//We should stay in bootloader mode
151:                   _asm goto BOOT_MAIN _endasm
0050  EF40     GOTO 0x80
0052  F000     NOP
152:               #else
153:           
154:                   //Ideally we shouldn't get here.  It is not recommended for the user to
155:                   //disable both the I/O pin check and flash signature checking
156:                   //simultaneously.  Doing so would make the application non-recoverable
157:                   //in the event of a failed bootload attempt (ex: due to power loss).
158:                   _asm goto REMAPPED_APPLICATION_RESET_VECTOR _endasm
159:           
160:               #endif
161:           }//end UninitializedMain
0054  0012     RETURN 0
---  C:/sw/github/eminor2/v2/controller/PIC_BOOT/BootPIC18NonJ.c  ---------------------------------------
1:             /*********************************************************************
2:              *
3:              *   Microchip USB HID Bootloader for PIC18F and PIC18LF versions of:
4:              *	 PIC18F4553/4458/2553/2458
5:              *	 PIC18F4550/4455/2550/2455
6:              *	 PIC18F4450/2450
7:              *   PIC18F14K50/13K50
8:              *   PIC18F45K50/44K50/25K50/24K50
9:              *
10:             *********************************************************************
11:             * FileName:        BootPIC18NonJ.c
12:             * Dependencies:    See INCLUDES section below
13:             * Processor:       PIC18
14:             * Compiler:        C18 3.45+
15:             * Company:         Microchip Technology, Inc.
16:             *
17:             * Software License Agreement
18:             *
19:             * The software supplied herewith by Microchip Technology Incorporated
20:             * (the "Company") for its PIC(R) Microcontroller is intended and
21:             * supplied to you, the Company's customer, for use solely and
22:             * exclusively on Microchip PICmicro Microcontroller products. The
23:             * software is owned by the Company and/or its supplier, and is
24:             * protected under applicable copyright laws. All rights are reserved.
25:             * Any use in violation of the foregoing restrictions may subject the
26:             * user to criminal sanctions under applicable laws, as well as to
27:             * civil liability for the breach of the terms and conditions of this
28:             * license.
29:             *
30:             * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
31:             * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
32:             * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
33:             * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
34:             * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
35:             * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
36:             *
37:             * File version     Date        Comment
38:             *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
39:             * 1.0			    06/19/08	Original Version.  Adapted from 
40:             *								MCHPFSUSB v2.1 HID Bootloader
41:             *								for PIC18F87J50 Family devices.
42:             * 2.9f             06/27/12    Added PIC18F45K50 Family devices
43:             *                              and some robustness enhancements.
44:             * 2.9j             06/11/13    Added sign flash command for ruggedized
45:             *                              software entry method recovery in event of
46:             *                              interrupt during erase/program/verify operation.
47:             *                              Implemented extended query command and bootloader
48:             *                              versioning system.  This release is version "1.01".
49:             *********************************************************************/
50:            
51:            /** I N C L U D E S **********************************************************/
52:            #include <p18cxxx.h>
53:            #include "typedefs.h"
54:            #include "string.h"
55:            #include "usb.h"
56:            #include "io_cfg.h"             // I/O pin mapping
57:            #include "BootPIC18NonJ.h"
58:            
59:            
60:            /** C O N S T A N T S **********************************************************/
61:            //The bootloader version, which the bootloader PC application can do extended query to get.
62:            //Value provided is expected to be in the format of BOOTLOADER_VERSION_MAJOR.BOOTLOADER_VERSION_MINOR
63:            //Ex: 1.01 would be BOOTLOADER_VERSION_MAJOR == 1, and BOOTLOADER_VERSION_MINOR == 1
64:            #define BOOTLOADER_VERSION_MAJOR         1 //Legal value 0-255
65:            #define BOOTLOADER_VERSION_MINOR         1 //Legal value 0-99.  (1 = X.01)
66:            
67:            
68:            //Section defining the address range to erase for the erase device command, along with the valid programming range to be reported by the QUERY_DEVICE command.
69:            #define PROGRAM_MEM_START_ADDRESS		0x001000 //Beginning of application program memory (not occupied by bootloader).  **THIS VALUE MUST BE ALIGNED WITH 64 BYTE BLOCK BOUNDRY** Also, in order to work correctly, make sure the StartPageToErase is set to erase this section.
70:            
71:            #if defined(__18F4550)||defined(__18F2550)||defined(__18F45K50)||defined(__18LF45K50)||defined(__18F25K50)||defined(__18LF25K50)
72:            	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
73:            	#define MaxPageToErase				511		 //Last 64 byte page of flash on the PIC18F4550
74:            	#define PROGRAM_MEM_STOP_ADDRESS	0x008000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
75:            	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
76:            	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
77:            	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
78:            	#define	UserIDSize					8
79:            	#define	DEVICE_WITH_EEPROM                   //Comment this out, if you never want the bootloader to reprogram the EEPROM space
80:            	#define	EEPROM_SIZE					0x100	 //256 bytes of EEPROM on this device
81:            	#define EEPROM_EFFECTIVE_ADDRESS	0xF00000
82:            	#define	WRITE_BLOCK_SIZE			0x20	 //32 byte programming block size on the PIC18F4550/PIC18F4553 family devices
83:                #define ERASE_PAGE_SIZE             64
84:                #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
85:            	
86:            #elif defined(__18F4553)||defined(__18F2553)
87:            	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
88:            	#define MaxPageToErase				511		 //Last 64 byte page of flash on the PIC18F4550
89:            	#define PROGRAM_MEM_STOP_ADDRESS	0x008000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
90:            	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
91:            	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
92:            	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
93:            	#define	UserIDSize					8
94:            	#define	DEVICE_WITH_EEPROM                   //Comment this out, if you never want the bootloader to reprogram the EEPROM space
95:            	#define	EEPROM_SIZE					0x100	 //256 bytes of EEPROM on this device
96:            	#define EEPROM_EFFECTIVE_ADDRESS    0xF00000
97:            	#define	WRITE_BLOCK_SIZE			0x20	 //32 byte programming block size on the PIC18F4550/PIC18F4553 family devices
98:                #define ERASE_PAGE_SIZE             64
99:                #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
100:           	
101:           #elif defined(__18F4455)||defined(__18F2455)
102:           	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
103:           	#define MaxPageToErase				383		 //Last 64 byte page of flash on the PIC18F4455
104:           	#define PROGRAM_MEM_STOP_ADDRESS	0x006000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
105:           	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
106:           	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
107:           	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
108:           	#define	UserIDSize					8
109:           	#define	DEVICE_WITH_EEPROM                   //Comment this out, if you never want the bootloader to reprogram the EEPROM space
110:           	#define	EEPROM_SIZE					0x100	 //256 bytes of EEPROM on this device
111:           	#define EEPROM_EFFECTIVE_ADDRESS    0xF00000
112:           	#define	WRITE_BLOCK_SIZE			0x20	 //32 byte programming block size on the PIC18F4550/PIC18F4553 family devices
113:               #define ERASE_PAGE_SIZE             64
114:               #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
115:           
116:           #elif defined(__18F4458)||defined(__18F2458)
117:           	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
118:           	#define MaxPageToErase				383		 //Last 64 byte page of flash on the PIC18F4455
119:           	#define PROGRAM_MEM_STOP_ADDRESS	0x006000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
120:           	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
121:           	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
122:           	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
123:           	#define	UserIDSize					8
124:           	#define	DEVICE_WITH_EEPROM                   //Comment this out, if you never want the bootloader to reprogram the EEPROM space
125:           	#define	EEPROM_SIZE					0x100	 //256 bytes of EEPROM on this device
126:           	#define EEPROM_EFFECTIVE_ADDRESS    0xF00000
127:           	#define	WRITE_BLOCK_SIZE			0x20	 //32 byte programming block size on the PIC18F4550/PIC18F4553 family devices
128:               #define ERASE_PAGE_SIZE             64
129:               #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
130:           
131:           #elif defined(__18F4450)||defined(__18F2450)
132:           	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
133:           	#define MaxPageToErase				255		 //Last 64 byte page of flash on the PIC18F4450
134:           	#define PROGRAM_MEM_STOP_ADDRESS	0x004000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
135:           	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
136:           	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
137:           	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
138:           	#define	UserIDSize					8
139:           	#define	WRITE_BLOCK_SIZE			0x10	 //16 byte programming block size on the PIC18F4450/2450 family devices
140:               #define ERASE_PAGE_SIZE             64
141:               #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
142:           
143:           #elif defined(__18F24K50)||defined(__18LF24K50) 
144:           	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
145:           	#define MaxPageToErase				255		 //Last 64 byte page of flash on the PIC18F4450
146:           	#define PROGRAM_MEM_STOP_ADDRESS	0x004000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
147:           	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
148:           	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
149:           	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
150:           	#define	UserIDSize					8
151:           	#define	DEVICE_WITH_EEPROM                   //Comment this out, if you never want the bootloader to reprogram the EEPROM space
152:           	#define	EEPROM_SIZE					0x100	 //256 bytes of EEPROM on this device
153:           	#define EEPROM_EFFECTIVE_ADDRESS    0xF00000
154:           	#define	WRITE_BLOCK_SIZE			0x10	 //16 byte programming block size on the PIC18F4450/2450 family devices
155:               #define ERASE_PAGE_SIZE             64
156:               #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
157:           
158:           #elif defined(__18F14K50) || defined(__18LF14K50)
159:           	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
160:           	#define MaxPageToErase				255		 //Last 64 byte page of flash on the PIC18F4455
161:           	#define PROGRAM_MEM_STOP_ADDRESS	0x004000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
162:           	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
163:           	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
164:           	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
165:           	#define	UserIDSize					8
166:           	#define	DEVICE_WITH_EEPROM                   //Comment this out, if you never want the bootloader to reprogram the EEPROM space
167:           	#define	EEPROM_SIZE					0x100	 //256 bytes of EEPROM on this device
168:           	#define EEPROM_EFFECTIVE_ADDRESS    0xF00000
169:               #define	WRITE_BLOCK_SIZE			0x10	 //16 byte programming block size on the PIC18F14K50 family devices
170:               #define ERASE_PAGE_SIZE             64
171:               #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
172:           
173:           #elif defined(__18F13K50) || defined(__18LF13K50)
174:           	#define StartPageToErase			64		 //The 4096 byte section from 0x000-0xFFF contains the bootloader and will not be erased
175:           	#define MaxPageToErase				127		 //Last 64 byte page of flash on the PIC18F4455
176:           	#define PROGRAM_MEM_STOP_ADDRESS	0x002000 //**MUST BE WORD ALIGNED (EVEN) ADDRESS.  This address does not get updated, but the one just below it does: IE: If AddressToStopPopulating = 0x200, 0x1FF is the last programmed address (0x200 not programmed)**	
177:           	#define CONFIG_WORDS_START_ADDRESS	0x300000 //0x300000 is CONFIG space for PIC18F4550/PIC18F4553/PIC18F4450 family devices
178:           	#define CONFIG_WORDS_SECTION_LENGTH	14   	 //14 bytes worth of Configuration words on the PIC18F4550/PIC18F4553/PIC18F4450 family devices
179:           	#define UserIDAddress				0x200000 //User ID is 8 bytes starting at 0x200000
180:           	#define	UserIDSize					8
181:           	#define	DEVICE_WITH_EEPROM                   //Comment this out, if you never want the bootloader to reprogram the EEPROM space
182:           	#define	EEPROM_SIZE					0x100	 //256 bytes of EEPROM on this device
183:           	#define EEPROM_EFFECTIVE_ADDRESS    0xF00000
184:           	#define	WRITE_BLOCK_SIZE			0x8	 //8 byte programming block size on the PIC18F14K50 family devices
185:               #define ERASE_PAGE_SIZE             64
186:               #define ERASE_PAGE_ADDRESS_MASK     0xFFFFC0 //AND mask value to isolate the start of an erase page from any flash address        
187:           
188:           #endif
189:           
190:           //Switch State Variable Choices
191:           #define	QUERY_DEVICE				0x02	//Command that the host uses to learn about the device (what regions can be programmed, and what type of memory is the region)
192:           #define	UNLOCK_CONFIG				0x03	//Note, this command is used for both locking and unlocking the config bits (see the "//Unlock Configs Command Definitions" below)
193:           #define ERASE_DEVICE				0x04	//Host sends this command to start an erase operation.  Firmware controls which pages should be erased.
194:           #define PROGRAM_DEVICE				0x05	//If host is going to send a full RequestDataBlockSize to be programmed, it uses this command.
195:           #define	PROGRAM_COMPLETE			0x06	//If host send less than a RequestDataBlockSize to be programmed, or if it wished to program whatever was left in the buffer, it uses this command.
196:           #define GET_DATA					0x07	//The host sends this command in order to read out memory from the device.  Used during verify (and read/export hex operations)
197:           #define	RESET_DEVICE				0x08	//Resets the microcontroller, so it can update the config bits (if they were programmed, and so as to leave the bootloader (and potentially go back into the main application)
198:           #define SIGN_FLASH					0x09	//The host PC application should send this command after the verify operation has completed successfully.  If checksums are used instead of a true verify (due to ALLOW_GET_DATA_COMMAND being commented), then the host PC application should send SIGN_FLASH command after is has verified the checksums are as exected. The firmware will then program the SIGNATURE_WORD into flash at the SIGNATURE_ADDRESS.
199:           #define QUERY_EXTENDED_INFO         0x0C    //Used by host PC app to get additional info about the device, beyond the basic NVM layout provided by the query device command
200:           
201:           //Unlock Configs Command Definitions
202:           #define UNLOCKCONFIG				0x00	//Sub-command for the ERASE_DEVICE command
203:           #define LOCKCONFIG					0x01	//Sub-command for the ERASE_DEVICE command
204:           
205:           //Query Device Response "Types" 
206:           #define	MEMORY_REGION_PROGRAM_MEM	0x01	//When the host sends a QUERY_DEVICE command, need to respond by populating a list of valid memory regions that exist in the device (and should be programmed)
207:           #define MEMORY_REGION_EEDATA		0x02
208:           #define MEMORY_REGION_CONFIG		0x03
209:           #define MEMORY_REGION_USERID		0x04
210:           #define	MEMORY_REGION_END		    0xFF	//Sort of serves as a "null terminator" like number, which denotes the end of the memory region list has been reached.
211:           #define BOOTLOADER_V1_01_OR_NEWER_FLAG   0xA5   //Tacked on in the VersionFlag byte, to indicate when using newer version of bootloader with extended query info available
212:           
213:           
214:           //BootState Variable States
215:           #define	IDLE						0x00
216:           #define NOT_IDLE    				0x01
217:           
218:           //OtherConstants
219:           #define INVALID_ADDRESS				0xFFFFFFFF
220:           #define CORRECT_UNLOCK_KEY          0xB5
221:           
222:           //Application and Microcontroller constants
223:           #define BYTES_PER_ADDRESS_PIC18		0x01		//One byte per address.  PIC24 uses 2 bytes for each address in the hex file.
224:           #define	USB_PACKET_SIZE				0x40
225:           #define WORDSIZE					0x02	//PIC18 uses 2 byte words, PIC24 uses 3 byte words.
226:           #define REQUEST_DATA_BLOCK_SIZE		0x3A	//Number of data bytes in a standard request to the PC.  Must be an even number from 2-58 (0x02-0x3A).  Larger numbers make better use of USB bandwidth and 
227:           											//yeild shorter program/verify times, but require more micrcontroller RAM for buffer space.
228:           
229:           
230:           
231:           /** USB Packet Request/Response Formatting Structure **********************************************************/
232:           typedef union 
233:           {
234:           		unsigned char Contents[USB_PACKET_SIZE];
235:           
236:           		//General command (with data in it) packet structure used by PROGRAM_DEVICE and GET_DATA commands 		
237:           		struct{
238:           			unsigned char Command;
239:           			unsigned long Address;
240:           			unsigned char Size;
241:           //			unsigned char PadBytes[58-REQUEST_DATA_BLOCK_SIZE];	//Uncomment this if using a smaller than 0x3A RequestDataBlockSize.  Compiler doesn't like 0 byte array when using 58 byte data block size.
242:           			unsigned char Data[REQUEST_DATA_BLOCK_SIZE];
243:           		};
244:           		
245:           		//This struct used for responding to QUERY_DEVICE command (on a device with four programmable sections)
246:           		struct{
247:           			unsigned char Command;
248:           			unsigned char PacketDataFieldSize;
249:           			unsigned char BytesPerAddress;
250:           			unsigned char Type1;
251:           			unsigned long Address1;
252:           			unsigned long Length1;
253:           			unsigned char Type2;
254:           			unsigned long Address2;
255:           			unsigned long Length2;
256:           			unsigned char Type3;
257:           			unsigned long Address3;
258:           			unsigned long Length3;
259:           			unsigned char Type4;
260:           			unsigned long Address4;
261:           			unsigned long Length4;						
262:           			unsigned char Type5;
263:           			unsigned long Address5;
264:           			unsigned long Length5;
265:           			unsigned char Type6;
266:           			unsigned long Address6;
267:           			unsigned long Length6;	
268:           			unsigned char VersionFlag;	    //Used by host software to identify if device is new enough to support QUERY_EXTENDED_INFO command	
269:           			unsigned char ExtraPadBytes[7];
270:           		};	
271:           		
272:           		struct{						//For UNLOCK_CONFIG command
273:           			unsigned char Command;
274:           			unsigned char LockValue;
275:           		};
276:           		
277:           		//Structure for the QUERY_EXTENDED_INFO command (and response)
278:           		struct{
279:               		unsigned char Command;
280:               		unsigned int BootloaderVersion;
281:               		unsigned int ApplicationVersion;
282:               		unsigned long SignatureAddress;
283:               		unsigned int SignatureValue;
284:               		unsigned long ErasePageSize;
285:               		unsigned char Config1LMask;
286:               		unsigned char Config1HMask;
287:               		unsigned char Config2LMask;
288:               		unsigned char Config2HMask;
289:               		unsigned char Config3LMask;
290:               		unsigned char Config3HMask;
291:               		unsigned char Config4LMask;
292:               		unsigned char Config4HMask;
293:               		unsigned char Config5LMask;
294:               		unsigned char Config5HMask;
295:               		unsigned char Config6LMask;
296:               		unsigned char Config6HMask;
297:               		unsigned char Config7LMask;
298:               		unsigned char Config7HMask;
299:                   };  		
300:           } PacketToFromPC;		
301:           	
302:           
303:           
304:           
305:           /** V A R I A B L E S ********************************************************/
306:           #pragma udata SomeSectionName2
307:           PacketToFromPC PacketFromPC;
308:           #pragma udata SomeSectionName3
309:           PacketToFromPC PacketToPC;
310:           #pragma udata WriteBufferSection
311:           unsigned char ProgrammingBuffer[ERASE_PAGE_SIZE];
312:           #pragma udata OtherVariablesSection
313:           unsigned short long ProgramMemStopAddress;
314:           unsigned char BootState;
315:           unsigned int ErasePageTracker;
316:           unsigned char BufferedDataIndex;
317:           unsigned short long ProgrammedPointer;
318:           unsigned char ConfigsLockValue;
319:           
320:           
321:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
322:           void WriteFlashBlock(void);
323:           void WriteConfigBits(void);
324:           void WriteEEPROM(void);
325:           void UnlockAndActivate(unsigned char UnlockKey);
326:           void ResetDeviceCleanly(void);
327:           void TableReadPostIncrement(void);
328:           void SignFlash(void);
329:           
330:           
331:           /** D E C L A R A T I O N S **************************************************/
332:           #pragma code 
333:           void UserInit(void)
334:           {
335:           	//Initialize bootloader state variables
336:           	BootState = IDLE;
00D8  0100     MOVLB 0x0
00DA  6BE5     CLRF BootState, BANKED
337:           	ProgrammedPointer = INVALID_ADDRESS;	
00DC  69E9     SETF ProgrammedPointer, BANKED
00DE  69EA     SETF 0xEA, BANKED
00E0  69EB     SETF 0xEB, BANKED
338:           	BufferedDataIndex = 0;
00E2  6BE8     CLRF BufferedDataIndex, BANKED
339:           	ConfigsLockValue = TRUE;
00E4  0E01     MOVLW 0x1
00E6  6FEC     MOVWF ConfigsLockValue, BANKED
340:           }//end UserInit
00E8  0012     RETURN 0
341:           
342:           /******************************************************************************
343:            * Function:        void ProcessIO(void)
344:            *
345:            * PreCondition:    None
346:            *
347:            * Input:           None
348:            *
349:            * Output:          None
350:            *
351:            * Side Effects:    None
352:            *
353:            * Overview:        This function receives/sends USB packets to/from the USB 
354:            *                  host.  It also processes any received OUT packets and
355:            *                  is reponsible for generating USB IN packet data.
356:            *
357:            * Note:            None
358:            *****************************************************************************/
359:           void ProcessIO(void)
360:           {
361:           	unsigned char i;
362:           
363:               //Check if we are busy processing a command yet or not.
364:           	if(BootState == IDLE)
00EA  0100     MOVLB 0x0
00EC  51E5     MOVF BootState, W, BANKED
00EE  E11E     BNZ 0x12C
365:           	{
366:               	//We are currently in the IDLE state waiting for a command from the
367:               	//PC software on the USB host.
368:           		if(!mHIDRxIsBusy())	//Did we receive a command?
00F0  0104     MOVLB 0x4
00F2  BF08     BTFSC 0x8, 7, BANKED
00F4  D193     BRA 0x41C
369:           		{
370:               		//We received a new command from the host.  Copy the OUT packet from 
371:               		//the host into a local buffer for processing.
372:           			HIDRxReport((char *)&PacketFromPC, USB_PACKET_SIZE);     //Also re-arms the OUT endpoint to be able to receive the next packet
00F6  0100     MOVLB 0x0
00F8  0E40     MOVLW 0x40
00FA  6FFE     MOVWF len, BANKED
00FC  0100     MOVLB 0x0
00FE  0EA1     MOVLW 0xA1
0100  6FFC     MOVWF buffer, BANKED
0102  0E00     MOVLW 0x0
0104  6FFD     MOVWF 0xFD, BANKED
0106  EC81     CALL 0xD02, 0
0108  F006     NOP
373:           			BootState = NOT_IDLE;   //Set flag letting state machine know it has a command that needs processing.
010A  0100     MOVLB 0x0
010C  0E01     MOVLW 0x1
010E  6FE5     MOVWF BootState, BANKED
374:           			
375:           			//Pre-initialize a response packet buffer (only used for some commands)
376:           			for(i = 0; i < USB_PACKET_SIZE; i++)		//Prepare the next packet we will send to the host, by initializing the entire packet to 0x00.
0110  6BED     CLRF i, BANKED
0112  0E40     MOVLW 0x40
0114  5DED     SUBWF i, W, BANKED
0116  E301     BNC 0x11A
0118  D181     BRA 0x41C
0128  2BED     INCF i, F, BANKED
012A  D7F3     BRA 0x112
377:           				PacketToPC.Contents[i] = 0;				//This saves code space, since we don't have to do it independently in the QUERY_DEVICE and GET_DATA cases.
011A  51ED     MOVF i, W, BANKED
011C  6AEA     CLRF FSR0H, ACCESS
011E  0F60     ADDLW 0x60
0120  6EE9     MOVWF FSR0L, ACCESS
0122  0E00     MOVLW 0x0
0124  22EA     ADDWFC FSR0H, F, ACCESS
0126  6AEF     CLRF INDF0, ACCESS
378:           		}
379:           	}
380:           	else //(BootState must be NOT_IDLE)
381:           	{	
382:           		switch(PacketFromPC.Command)
012C  0100     MOVLB 0x0
012E  51A1     MOVF PacketFromPC, W, BANKED
0130  0A08     XORLW 0x8
0132  E101     BNZ 0x136
0134  D170     BRA 0x416
0136  0A04     XORLW 0x4
0138  E101     BNZ 0x13C
013A  D131     BRA 0x39E
013C  0A05     XORLW 0x5
013E  E101     BNZ 0x142
0140  D12C     BRA 0x39A
0142  0A0E     XORLW 0xE
0144  E101     BNZ 0x148
0146  D0F5     BRA 0x332
0148  0A01     XORLW 0x1
014A  E101     BNZ 0x14E
014C  D0EC     BRA 0x326
014E  0A03     XORLW 0x3
0150  E101     BNZ 0x154
0152  D094     BRA 0x27C
0154  0A01     XORLW 0x1
0156  E04C     BZ 0x1F0
0158  0A07     XORLW 0x7
015A  E040     BZ 0x1DC
015C  0A01     XORLW 0x1
015E  E001     BZ 0x162
0160  D15B     BRA 0x418
383:           		{
384:           			case QUERY_DEVICE:
385:           				//Prepare a response packet, which lets the PC software know about the memory ranges of this device.
386:           				PacketToPC.Command = QUERY_DEVICE;
0162  0100     MOVLB 0x0
0164  0E02     MOVLW 0x2
0166  6F60     MOVWF PacketToPC, BANKED
387:           				PacketToPC.PacketDataFieldSize = REQUEST_DATA_BLOCK_SIZE;
0168  0E3A     MOVLW 0x3A
016A  6F61     MOVWF 0x61, BANKED
388:           				PacketToPC.BytesPerAddress = BYTES_PER_ADDRESS_PIC18;
016C  0E01     MOVLW 0x1
016E  6F62     MOVWF 0x62, BANKED
389:           				PacketToPC.Type1 = MEMORY_REGION_PROGRAM_MEM;
0170  6F63     MOVWF 0x63, BANKED
390:           				PacketToPC.Address1 = (unsigned long)PROGRAM_MEM_START_ADDRESS;
0172  6B64     CLRF 0x64, BANKED
0174  0E10     MOVLW 0x10
0176  6F65     MOVWF 0x65, BANKED
0178  6B66     CLRF 0x66, BANKED
017A  6B67     CLRF 0x67, BANKED
391:           				PacketToPC.Length1 = (unsigned long)(PROGRAM_MEM_STOP_ADDRESS - PROGRAM_MEM_START_ADDRESS);	//Size of program memory area
017C  6B68     CLRF 0x68, BANKED
017E  0E70     MOVLW 0x70
0180  6F69     MOVWF 0x69, BANKED
0182  6B6A     CLRF 0x6A, BANKED
0184  6B6B     CLRF 0x6B, BANKED
392:           				PacketToPC.Type2 = MEMORY_REGION_CONFIG;
0186  0E03     MOVLW 0x3
0188  6F6C     MOVWF 0x6C, BANKED
393:           				PacketToPC.Address2 = (unsigned long)CONFIG_WORDS_START_ADDRESS;
018A  6B6D     CLRF 0x6D, BANKED
018C  6B6E     CLRF 0x6E, BANKED
018E  0E30     MOVLW 0x30
0190  6F6F     MOVWF 0x6F, BANKED
0192  6B70     CLRF 0x70, BANKED
394:           				PacketToPC.Length2 = (unsigned long)CONFIG_WORDS_SECTION_LENGTH;
0194  0E0E     MOVLW 0xE
0196  6F71     MOVWF 0x71, BANKED
0198  6B72     CLRF 0x72, BANKED
019A  6B73     CLRF 0x73, BANKED
019C  6B74     CLRF 0x74, BANKED
395:           				PacketToPC.Type3 = MEMORY_REGION_USERID;		//Not really program memory (User ID), but may be treated as it it was as far as the host is concerned
019E  0E04     MOVLW 0x4
01A0  6F75     MOVWF 0x75, BANKED
396:           				PacketToPC.Address3 = (unsigned long)UserIDAddress;
01A2  6B76     CLRF 0x76, BANKED
01A4  6B77     CLRF 0x77, BANKED
01A6  0E20     MOVLW 0x20
01A8  6F78     MOVWF 0x78, BANKED
01AA  6B79     CLRF 0x79, BANKED
397:           				PacketToPC.Length3 = (unsigned long)(UserIDSize);
01AC  0E08     MOVLW 0x8
01AE  6F7A     MOVWF 0x7A, BANKED
01B0  6B7B     CLRF 0x7B, BANKED
01B2  6B7C     CLRF 0x7C, BANKED
01B4  6B7D     CLRF 0x7D, BANKED
398:           				PacketToPC.Type4 = MEMORY_REGION_END;
399:           				#if defined(DEVICE_WITH_EEPROM)
400:           					PacketToPC.Type4 = MEMORY_REGION_EEDATA;
01B6  0E02     MOVLW 0x2
01B8  6F7E     MOVWF 0x7E, BANKED
401:           					PacketToPC.Address4 = (unsigned long)EEPROM_EFFECTIVE_ADDRESS;
01BA  6B7F     CLRF 0x7F, BANKED
01BC  6B80     CLRF 0x80, BANKED
01BE  0EF0     MOVLW 0xF0
01C0  6F81     MOVWF 0x81, BANKED
01C2  6B82     CLRF 0x82, BANKED
402:           					PacketToPC.Length4 = (unsigned long)EEPROM_SIZE;
01C4  6B83     CLRF 0x83, BANKED
01C6  0E01     MOVLW 0x1
01C8  6F84     MOVWF 0x84, BANKED
01CA  6B85     CLRF 0x85, BANKED
01CC  6B86     CLRF 0x86, BANKED
403:           					PacketToPC.Type5 = MEMORY_REGION_END;
01CE  6987     SETF 0x87, BANKED
404:           				#endif
405:           				PacketToPC.VersionFlag = BOOTLOADER_V1_01_OR_NEWER_FLAG;
01D0  0EA5     MOVLW 0xA5
01D2  6F99     MOVWF 0x99, BANKED
406:           				//Init pad bytes to 0x00...  Already done after we received the QUERY_DEVICE command (just after calling HIDRxReport()).
407:           	
408:           	            //Now send the packet to the USB host software, assuming the USB endpoint is available/ready to accept new data.
409:           				if(!mHIDTxIsBusy())
01D4  0104     MOVLB 0x4
01D6  BF0C     BTFSC 0xC, 7, BANKED
01D8  D121     BRA 0x41C
410:           				{
411:           					HIDTxReport((char *)&PacketToPC, USB_PACKET_SIZE);
412:           					BootState = IDLE;
413:           				}
414:           				break;
01DA  D0DC     BRA 0x394
415:           			case UNLOCK_CONFIG:
416:           				ConfigsLockValue = TRUE;
01DC  0100     MOVLB 0x0
01DE  0E01     MOVLW 0x1
01E0  6FEC     MOVWF ConfigsLockValue, BANKED
417:           				if(PacketFromPC.LockValue == UNLOCKCONFIG)
01E2  0100     MOVLB 0x0
01E4  51A2     MOVF 0xA2, W, BANKED
01E6  E001     BZ 0x1EA
01E8  D113     BRA 0x410
418:           				{
419:           					ConfigsLockValue = FALSE;
01EA  0100     MOVLB 0x0
01EC  6BEC     CLRF ConfigsLockValue, BANKED
420:           				}
421:           				BootState = IDLE;
422:           				break;
01EE  D110     BRA 0x410
423:           			case ERASE_DEVICE:
424:           				//First erase main program flash memory
425:           				for(ErasePageTracker = StartPageToErase; ErasePageTracker < (unsigned int)(MaxPageToErase + 1); ErasePageTracker++)
01F0  0E40     MOVLW 0x40
01F2  0100     MOVLB 0x0
01F4  6FE6     MOVWF ErasePageTracker, BANKED
01F6  6BE7     CLRF 0xE7, BANKED
01F8  0E00     MOVLW 0x0
01FA  5DE6     SUBWF ErasePageTracker, W, BANKED
01FC  0E02     MOVLW 0x2
01FE  59E7     SUBWFB 0xE7, W, BANKED
0200  E21F     BC 0x240
0236  0100     MOVLB 0x0
0238  2BE6     INCF ErasePageTracker, F, BANKED
023A  0E00     MOVLW 0x0
023C  23E7     ADDWFC 0xE7, F, BANKED
023E  D7DC     BRA 0x1F8
426:           				{
427:           					ClearWatchdog();
0202  DA2F     RCALL ClearWatchdog
428:           					TBLPTR = ((unsigned short long)ErasePageTracker << 6);
0204  C0E6     MOVFF ErasePageTracker, __tmp_0
0206  F000     NOP
0208  C0E7     MOVFF 0xE7, 0x1
020A  F001     NOP
020C  6A02     CLRF 0x2, ACCESS
020E  0E06     MOVLW 0x6
0210  0B1F     ANDLW 0x1F
0212  C0E6     MOVFF ErasePageTracker, TBLPTRL
0214  FFF6     NOP
0216  C0E7     MOVFF 0xE7, TBLPTRH
0218  FFF7     NOP
021A  C002     MOVFF 0x2, TBLPTRU
021C  FFF8     NOP
021E  E006     BZ 0x22C
0220  90D8     BCF STATUS, 0, ACCESS
0222  36F6     RLCF TBLPTRL, F, ACCESS
0224  36F7     RLCF TBLPTRH, F, ACCESS
0226  36F8     RLCF TBLPTRU, F, ACCESS
0228  06E8     DECF WREG, F, ACCESS
022A  E1FA     BNZ 0x220
429:           					EECON1 = 0b10010100;	//Prepare for erasing flash memory
022C  0E94     MOVLW 0x94
022E  6EA6     MOVWF EECON1, ACCESS
430:           					UnlockAndActivate(CORRECT_UNLOCK_KEY);
0230  DA24     RCALL __pa_1
431:           					USBDriverService(); 	//Call USBDriverService() periodically to prevent falling off the bus if any SETUP packets should happen to arrive.
0232  ECC6     CALL 0xD8C, 0
0234  F006     NOP
432:           				}
433:           				
434:           				#if defined(DEVICE_WITH_EEPROM)
435:               				//Now erase EEPROM (if any is present on the device)
436:               				i = EEPROM_EFFECTIVE_ADDRESS & (EEPROM_SIZE-1);
0240  6BED     CLRF i, BANKED
437:               				do{
438:               					EEADR = i;
0242  C0ED     MOVFF i, EEADR
0244  FFA9     NOP
439:               					EEDATA = 0xFF;
0246  68A8     SETF EEDATA, ACCESS
440:               					EECON1 = 0b00000100;	//EEPROM Write mode
0248  0E04     MOVLW 0x4
024A  6EA6     MOVWF EECON1, ACCESS
441:               					USBDriverService(); 	//Call USBDriverService() periodically to prevent falling off the bus if any SETUP packets should happen to arrive.
024C  ECC6     CALL 0xD8C, 0
024E  F006     NOP
442:               					UnlockAndActivate(CORRECT_UNLOCK_KEY);					
0250  DA14     RCALL __pa_1
443:               				}while(i++<((EEPROM_SIZE-1)+(EEPROM_EFFECTIVE_ADDRESS & (EEPROM_SIZE-1))));
0252  0100     MOVLB 0x0
0254  51ED     MOVF i, W, BANKED
0256  2BED     INCF i, F, BANKED
0258  6E00     MOVWF __tmp_0, ACCESS
025A  6A01     CLRF 0x1, ACCESS
025C  6A02     CLRF 0x2, ACCESS
025E  0EFF     MOVLW 0xFF
0260  5C00     SUBWF __tmp_0, W, ACCESS
0262  0E00     MOVLW 0x0
0264  5801     SUBWFB 0x1, W, ACCESS
0266  0E00     MOVLW 0x0
0268  5802     SUBWFB 0x2, W, ACCESS
026A  E3EB     BNC 0x242
444:           				#endif
445:           
446:           				//Now erase the User ID space (0x200000 to 0x200007)
447:           				TBLPTR = UserIDAddress;
026C  6AF6     CLRF TBLPTRL, ACCESS
026E  6AF7     CLRF TBLPTRH, ACCESS
0270  0E20     MOVLW 0x20
0272  6EF8     MOVWF TBLPTRU, ACCESS
448:           				EECON1 = 0b10010100;	//Prepare for erasing flash memory
0274  0E94     MOVLW 0x94
0276  6EA6     MOVWF EECON1, ACCESS
449:           				UnlockAndActivate(CORRECT_UNLOCK_KEY);
0278  DA00     RCALL __pa_1
450:           
451:           				BootState = IDLE;				
452:           				break;
027A  D0CA     BRA 0x410
453:           			case PROGRAM_DEVICE:
454:           				//Check if host is trying to program the config bits
455:           				if(PacketFromPC.Contents[3] == 0x30) // 			//PacketFromPC.Contents[3] is bits 23:16 of the address.  
027C  0E30     MOVLW 0x30
027E  5DA4     SUBWF 0xA4, W, BANKED
0280  E106     BNZ 0x28E
456:           				{													//0x30 implies config bits
457:           					if(ConfigsLockValue == FALSE)
0282  0100     MOVLB 0x0
0284  51EC     MOVF ConfigsLockValue, W, BANKED
0286  E001     BZ 0x28A
0288  D0C3     BRA 0x410
458:           					{
459:           						WriteConfigBits();		//Doesn't get reprogrammed if the UNLOCK_CONFIG (LockValue = UNLOCKCONFIG) command hasn't previously been sent
028A  D992     RCALL WriteConfigBits
460:           					}
461:           					BootState = IDLE;
462:           					break;
028C  D0C1     BRA 0x410
463:           				}
464:           
465:           				#if defined(DEVICE_WITH_EEPROM)
466:               				//Check if host is trying to program the EEPROM
467:               				if(PacketFromPC.Contents[3] == 0xF0)	//PacketFromPC.Contents[3] is bits 23:16 of the address.  
028E  0EF0     MOVLW 0xF0
0290  5DA4     SUBWF 0xA4, W, BANKED
0292  E102     BNZ 0x298
468:               				{										//0xF0 implies EEPROM
469:               					WriteEEPROM();
0294  D9B3     RCALL WriteEEPROM
470:               					BootState = IDLE;
471:               					break;
0296  D0BC     BRA 0x410
472:               				}
473:           				#endif
474:           
475:           				if(ProgrammedPointer == (unsigned short long)INVALID_ADDRESS)
0298  68E8     SETF WREG, ACCESS
029A  0100     MOVLB 0x0
029C  19E9     XORWF ProgrammedPointer, W, BANKED
029E  E10C     BNZ 0x2B8
02A0  68E8     SETF WREG, ACCESS
02A2  19EA     XORWF 0xEA, W, BANKED
02A4  E109     BNZ 0x2B8
02A6  68E8     SETF WREG, ACCESS
02A8  19EB     XORWF 0xEB, W, BANKED
02AA  E106     BNZ 0x2B8
476:           					ProgrammedPointer = PacketFromPC.Address;
02AC  C0A2     MOVFF 0xA2, ProgrammedPointer
02AE  F0E9     NOP
02B0  C0A3     MOVFF 0xA3, 0xEA
02B2  F0EA     NOP
02B4  C0A4     MOVFF 0xA4, 0xEB
02B6  F0EB     NOP
477:           				
478:           				if(ProgrammedPointer == (unsigned short long)PacketFromPC.Address)
02B8  0EE9     MOVLW 0xE9
02BA  6EE9     MOVWF FSR0L, ACCESS
02BC  0E00     MOVLW 0x0
02BE  6EEA     MOVWF FSR0H, ACCESS
02C0  50EE     MOVF POSTINC0, W, ACCESS
02C2  0100     MOVLB 0x0
02C4  19A2     XORWF 0xA2, W, BANKED
02C6  E001     BZ 0x2CA
02C8  D0A3     BRA 0x410
02CA  50EE     MOVF POSTINC0, W, ACCESS
02CC  19A3     XORWF 0xA3, W, BANKED
02CE  E001     BZ 0x2D2
02D0  D09F     BRA 0x410
02D2  50EE     MOVF POSTINC0, W, ACCESS
02D4  19A4     XORWF 0xA4, W, BANKED
02D6  E001     BZ 0x2DA
02D8  D09B     BRA 0x410
02DA  E001     BZ 0x2DE
02DC  D099     BRA 0x410
479:           				{
480:           					for(i = 0; i < PacketFromPC.Size; i++)
02DE  0100     MOVLB 0x0
02E0  6BED     CLRF i, BANKED
02E2  0100     MOVLB 0x0
02E4  51A6     MOVF 0xA6, W, BANKED
02E6  0100     MOVLB 0x0
02E8  5DED     SUBWF i, W, BANKED
02EA  E301     BNC 0x2EE
02EC  D091     BRA 0x410
0320  0100     MOVLB 0x0
0322  2BED     INCF i, F, BANKED
0324  D7DE     BRA 0x2E2
481:           					{
482:           						ProgrammingBuffer[BufferedDataIndex] = PacketFromPC.Data[i+(REQUEST_DATA_BLOCK_SIZE-PacketFromPC.Size)];	//Data field is right justified.  Need to put it in the buffer left justified.
02EE  D9BD     RCALL __pa_0
02F0  0FA7     ADDLW 0xA7
02F2  6EE9     MOVWF FSR0L, ACCESS
02F4  0E00     MOVLW 0x0
02F6  22EA     ADDWFC FSR0H, F, ACCESS
02F8  50EF     MOVF INDF0, W, ACCESS
02FA  6EE6     MOVWF POSTINC1, ACCESS
02FC  51E8     MOVF BufferedDataIndex, W, BANKED
02FE  6AEA     CLRF FSR0H, ACCESS
0300  0F60     ADDLW 0x60
0302  6EE9     MOVWF FSR0L, ACCESS
0304  0E02     MOVLW 0x2
0306  22EA     ADDWFC FSR0H, F, ACCESS
0308  52E5     MOVF POSTDEC1, F, ACCESS
030A  50E7     MOVF INDF1, W, ACCESS
030C  6EEF     MOVWF INDF0, ACCESS
483:           						BufferedDataIndex++;
030E  2BE8     INCF BufferedDataIndex, F, BANKED
484:           						ProgrammedPointer++;
0310  2BE9     INCF ProgrammedPointer, F, BANKED
0312  0E00     MOVLW 0x0
0314  23EA     ADDWFC 0xEA, F, BANKED
0316  23EB     ADDWFC 0xEB, F, BANKED
485:           						if(BufferedDataIndex == WRITE_BLOCK_SIZE)
0318  0E20     MOVLW 0x20
031A  5DE8     SUBWF BufferedDataIndex, W, BANKED
031C  E101     BNZ 0x320
486:           						{
487:           							WriteFlashBlock();
031E  D8E4     RCALL WriteFlashBlock
488:           						}
489:           					}
490:           				}
491:           				//else host sent us a non-contiguous packet address...  to make this firmware simpler, host should not do this without sending a PROGRAM_COMPLETE command in between program sections.
492:           				BootState = IDLE;
493:           				break;
494:           			case PROGRAM_COMPLETE:
495:           				WriteFlashBlock();
0326  D8E0     RCALL WriteFlashBlock
496:           				ProgrammedPointer = INVALID_ADDRESS;		//Reinitialize pointer to an invalid range, so we know the next PROGRAM_DEVICE will be the start address of a contiguous section.
0328  0100     MOVLB 0x0
032A  69E9     SETF ProgrammedPointer, BANKED
032C  69EA     SETF 0xEA, BANKED
032E  69EB     SETF 0xEB, BANKED
497:           				BootState = IDLE;
498:           				break;
0330  D070     BRA 0x412
499:           			case GET_DATA:
500:           				//Init pad bytes to 0x00...  Already done after we received the QUERY_DEVICE command (just after calling HIDRxReport()).
501:           				PacketToPC.Command = GET_DATA;
0332  0100     MOVLB 0x0
0334  0E07     MOVLW 0x7
0336  6F60     MOVWF PacketToPC, BANKED
502:           				PacketToPC.Address = PacketFromPC.Address;
0338  C0A2     MOVFF 0xA2, 0x61
033A  F061     NOP
033C  C0A3     MOVFF 0xA3, 0x62
033E  F062     NOP
0340  C0A4     MOVFF 0xA4, 0x63
0342  F063     NOP
0344  C0A5     MOVFF 0xA5, 0x64
0346  F064     NOP
503:           				PacketToPC.Size = PacketFromPC.Size;
0348  C0A6     MOVFF 0xA6, 0x65
034A  F065     NOP
504:           
505:           				TBLPTR = (unsigned short long)PacketFromPC.Address;
034C  C0A2     MOVFF 0xA2, TBLPTRL
034E  FFF6     NOP
0350  C0A3     MOVFF 0xA3, TBLPTRH
0352  FFF7     NOP
0354  C0A4     MOVFF 0xA4, TBLPTRU
0356  FFF8     NOP
506:           				for(i = 0; i < PacketFromPC.Size; i++)
0358  0100     MOVLB 0x0
035A  6BED     CLRF i, BANKED
035C  0100     MOVLB 0x0
035E  51A6     MOVF 0xA6, W, BANKED
0360  0100     MOVLB 0x0
0362  5DED     SUBWF i, W, BANKED
0364  E214     BC 0x38E
038A  2BED     INCF i, F, BANKED
038C  D7E7     BRA 0x35C
507:           				{
508:           					if(PacketFromPC.Contents[3] == 0xF0)	//PacketFromPC.Contents[3] is bits 23:16 of the address.  
0366  0EF0     MOVLW 0xF0
0368  0100     MOVLB 0x0
036A  5DA4     SUBWF 0xA4, W, BANKED
036C  E10A     BNZ 0x382
509:           					{										//0xF0 implies EEPROM, which doesn't use the table pointer to read from
510:           						#if defined(DEVICE_WITH_EEPROM)
511:           						EEADR = (((unsigned char)PacketFromPC.Address) + i);	//The bits 7:0 are 1:1 mapped to the EEPROM address space values
036E  51A2     MOVF 0xA2, W, BANKED
0370  0100     MOVLB 0x0
0372  25ED     ADDWF i, W, BANKED
0374  6EA9     MOVWF EEADR, ACCESS
512:           						EECON1 = 0b00000000;	//EEPROM read mode
0376  6AA6     CLRF EECON1, ACCESS
513:           						EECON1bits.RD = 1;
0378  80A6     BSF EECON1, 0, ACCESS
514:           						PacketToPC.Data[i+((USB_PACKET_SIZE - 6) - PacketFromPC.Size)] = EEDATA;					
037A  D984     RCALL __pa_2
037C  CFA8     MOVFF EEDATA, INDF0
037E  FFEF     NOP
0684  DFF2     RCALL __pa_0
0686  0F66     ADDLW 0x66
0688  6EE9     MOVWF FSR0L, ACCESS
068A  0E00     MOVLW 0x0
068C  22EA     ADDWFC FSR0H, F, ACCESS
068E  0012     RETURN 0
515:           						#endif
516:           					}
517:           					else	//else must have been a normal program memory region, or one that can be read from with the table pointer
0380  D004     BRA 0x38A
518:           					{
519:               					TableReadPostIncrement();
0382  D971     RCALL TableReadPostIncrement
520:                                   PacketToPC.Data[i+((USB_PACKET_SIZE - 6) - PacketFromPC.Size)]=TABLAT;
0384  D97F     RCALL __pa_2
0386  CFF5     MOVFF TABLAT, INDF0
0388  FFEF     NOP
066A  0E3A     MOVLW 0x3A
066C  0100     MOVLB 0x0
066E  80D8     BSF STATUS, 0, ACCESS
0670  55A6     SUBFWB 0xA6, W, BANKED
0672  0100     MOVLB 0x0
0674  25ED     ADDWF i, W, BANKED
0676  6AEA     CLRF FSR0H, ACCESS
0678  0012     RETURN 0
521:           					}
522:           				}
523:           				
524:           				//Assuming the USB IN (to host) buffer is available/ready, copy the
525:           				//data over so it can get sent to the USB host software.
526:           				if(!mHIDTxIsBusy())
038E  0104     MOVLB 0x4
0390  BF0C     BTFSC 0xC, 7, BANKED
0392  D044     BRA 0x41C
527:           				{
528:           					HIDTxReport((char *)&PacketToPC, USB_PACKET_SIZE);
0394  0100     MOVLB 0x0
0396  0E40     MOVLW 0x40
529:           					BootState = IDLE;
530:           				}
531:           				break;
0398  D033     BRA 0x400
532:           			case SIGN_FLASH:
533:           			    SignFlash();
039A  D841     RCALL SignFlash
534:           			    BootState = IDLE;
535:           			    break;
039C  D039     BRA 0x410
536:           			case QUERY_EXTENDED_INFO:
537:           			    //Prepare a response packet with the QUERY_EXTENDED_INFO response info in it.
538:           			    //This command is only supported in bootloader firmware verison 1.01 or later.
539:           			    //Make sure the regular QUERY_DEVIER reponse packet value "PacketToPC.Type6" is = BOOTLOADER_V1_01_OR_NEWER_FLAG;
540:           			    //to let the host PC software know that the QUERY_EXTENDED_INFO command is implemented
541:           			    //in this firmware and is available for requesting by the host software.
542:           			    PacketToPC.Command = QUERY_EXTENDED_INFO;   //Echo the command byte
039E  0100     MOVLB 0x0
03A0  0E0C     MOVLW 0xC
03A2  6F60     MOVWF PacketToPC, BANKED
543:           			    PacketToPC.BootloaderVersion = ((unsigned int)BOOTLOADER_VERSION_MAJOR << 8)| BOOTLOADER_VERSION_MINOR;
03A4  0E01     MOVLW 0x1
03A6  6F61     MOVWF 0x61, BANKED
03A8  6F62     MOVWF 0x62, BANKED
544:           			    PacketToPC.ApplicationVersion = *(rom unsigned int*)APP_VERSION_ADDRESS;
03AA  0E16     MOVLW 0x16
03AC  6EF6     MOVWF TBLPTRL, ACCESS
03AE  0E10     MOVLW 0x10
03B0  6EF7     MOVWF TBLPTRH, ACCESS
03B2  0009     TBLRD*+
03B4  CFF5     MOVFF TABLAT, 0x63
03B6  F063     NOP
03B8  000A     TBLRD*-
03BA  CFF5     MOVFF TABLAT, 0x64
03BC  F064     NOP
545:           			    PacketToPC.SignatureAddress = APP_SIGNATURE_ADDRESS;
03BE  0E06     MOVLW 0x6
03C0  6F65     MOVWF 0x65, BANKED
03C2  0E10     MOVLW 0x10
03C4  6F66     MOVWF 0x66, BANKED
03C6  6B67     CLRF 0x67, BANKED
03C8  6B68     CLRF 0x68, BANKED
546:           			    PacketToPC.SignatureValue = APP_SIGNATURE_VALUE;
03CA  0E0D     MOVLW 0xD
03CC  6F69     MOVWF 0x69, BANKED
03CE  0E60     MOVLW 0x60
03D0  6F6A     MOVWF 0x6A, BANKED
547:           			    PacketToPC.ErasePageSize = ERASE_PAGE_SIZE;
03D2  0E40     MOVLW 0x40
03D4  6F6B     MOVWF 0x6B, BANKED
03D6  6B6C     CLRF 0x6C, BANKED
03D8  6B6D     CLRF 0x6D, BANKED
03DA  6B6E     CLRF 0x6E, BANKED
548:           			    PacketToPC.Config1LMask = 0xFF;
03DC  696F     SETF 0x6F, BANKED
549:           			    PacketToPC.Config1HMask = 0xFF;
03DE  6970     SETF 0x70, BANKED
550:           			    PacketToPC.Config2LMask = 0xFF;
03E0  6971     SETF 0x71, BANKED
551:           			    PacketToPC.Config2HMask = 0xFF;
03E2  6972     SETF 0x72, BANKED
552:           			    PacketToPC.Config3LMask = 0x00;
03E4  6B73     CLRF 0x73, BANKED
553:           			    PacketToPC.Config3HMask = 0xFF;
03E6  6974     SETF 0x74, BANKED
554:           			    PacketToPC.Config4LMask = 0xFF;
03E8  6975     SETF 0x75, BANKED
555:           			    PacketToPC.Config4HMask = 0x00;
03EA  6B76     CLRF 0x76, BANKED
556:           			    PacketToPC.Config5LMask = 0xFF;
03EC  6977     SETF 0x77, BANKED
557:           			    PacketToPC.Config5HMask = 0xFF;
03EE  6978     SETF 0x78, BANKED
558:           			    PacketToPC.Config6LMask = 0xFF;
03F0  6979     SETF 0x79, BANKED
559:           			    PacketToPC.Config6HMask = 0xFF;
03F2  697A     SETF 0x7A, BANKED
560:           			    PacketToPC.Config7LMask = 0xFF;
03F4  697B     SETF 0x7B, BANKED
561:           			    PacketToPC.Config7HMask = 0xFF;
03F6  697C     SETF 0x7C, BANKED
562:           			    
563:           			    //Now actually command USB to send the packet to the host    			    
564:           			    if(!mHIDTxIsBusy())
03F8  0104     MOVLB 0x4
03FA  BF0C     BTFSC 0xC, 7, BANKED
03FC  D00F     BRA 0x41C
565:           			    {
566:           					HIDTxReport((char *)&PacketToPC, USB_PACKET_SIZE);
03FE  0100     MOVLB 0x0
0400  6FFA     MOVWF len, BANKED
0402  0100     MOVLB 0x0
0404  0E60     MOVLW 0x60
0406  6FF8     MOVWF buffer, BANKED
0408  0E00     MOVLW 0x0
040A  6FF9     MOVWF 0xF9, BANKED
040C  EC5B     CALL 0xCB6, 0
040E  F006     NOP
567:               			    BootState = IDLE;   //Packet will be sent, go back to idle state ready for next command from host
0410  0100     MOVLB 0x0
0412  6BE5     CLRF BootState, BANKED
568:           		        }	    
569:           			    break;
0414  0012     RETURN 0
570:           			case RESET_DEVICE:
571:           			    ResetDeviceCleanly();
0416  D850     RCALL ResetDeviceCleanly
572:           			    //break;    //no need, commented to save space
573:           			default:
574:           			    //Should never hit the default
575:           			    BootState = IDLE;
0418  0100     MOVLB 0x0
041A  6BE5     CLRF BootState, BANKED
576:           		}//End switch
577:           	}//End if/else
578:           
579:           }//End ProcessIO()
041C  0012     RETURN 0
580:           
581:           
582:           
583:           //Should be called once, only after the regular erase/program/verify sequence 
584:           //has completed successfully.  This function will program the magic
585:           //APP_SIGNATURE_VALUE into the magic APP_SIGNATURE_ADDRESS in the application
586:           //flash memory space.  This is used on the next bootup to know that the the
587:           //flash memory image of the application is intact, and can be executed.
588:           //This is useful for recovery purposes, in the event that an unexpected
589:           //failure occurs during the erase/program sequence (ex: power loss or user
590:           //unplugging the USB cable).
591:           void SignFlash(void)
592:           {
593:               static unsigned char i;
594:               
595:               //First read in the erase page contents of the page with the signature WORD
596:               //in it, and temporarily store it in a RAM buffer.
597:               TBLPTR = (APP_SIGNATURE_ADDRESS & ERASE_PAGE_ADDRESS_MASK);
041E  6AF6     CLRF TBLPTRL, ACCESS
0420  0E10     MOVLW 0x10
0422  6EF7     MOVWF TBLPTRH, ACCESS
0424  6AF8     CLRF TBLPTRU, ACCESS
598:               for(i = 0; i < ERASE_PAGE_SIZE; i++)
0426  0100     MOVLB 0x0
0428  6BEE     CLRF i, BANKED
042A  0E40     MOVLW 0x40
042C  0100     MOVLB 0x0
042E  5DEE     SUBWF i, W, BANKED
0430  E20D     BC 0x44C
0446  0100     MOVLB 0x0
0448  2BEE     INCF i, F, BANKED
044A  D7EF     BRA 0x42A
599:               {
600:                   _asm tblrdpostinc _endasm  
0432  0009     TBLRD*+
601:                   ProgrammingBuffer[i] = TABLAT;        
0434  0100     MOVLB 0x0
0436  51EE     MOVF i, W, BANKED
0438  6AEA     CLRF FSR0H, ACCESS
043A  0F60     ADDLW 0x60
043C  6EE9     MOVWF FSR0L, ACCESS
043E  0E02     MOVLW 0x2
0440  22EA     ADDWFC FSR0H, F, ACCESS
0442  CFF5     MOVFF TABLAT, INDF0
0444  FFEF     NOP
602:               }    
603:               
604:               //Now change the signature WORD value at the correct address in the RAM buffer
605:               ProgrammingBuffer[(APP_SIGNATURE_ADDRESS & ~ERASE_PAGE_ADDRESS_MASK)] = (unsigned char)APP_SIGNATURE_VALUE;
044C  0102     MOVLB 0x2
044E  0E0D     MOVLW 0xD
0450  6F66     MOVWF 0x66, BANKED
606:               ProgrammingBuffer[(APP_SIGNATURE_ADDRESS & ~ERASE_PAGE_ADDRESS_MASK) + 1] = (unsigned char)(APP_SIGNATURE_VALUE >> 8);
0452  0102     MOVLB 0x2
0454  0E60     MOVLW 0x60
0456  6F67     MOVWF 0x67, BANKED
607:               
608:               //Now erase the flash memory block with the signature WORD in it
609:               TBLPTR = APP_SIGNATURE_ADDRESS & ERASE_PAGE_ADDRESS_MASK;
0458  6AF6     CLRF TBLPTRL, ACCESS
045A  0E10     MOVLW 0x10
045C  6EF7     MOVWF TBLPTRH, ACCESS
045E  6AF8     CLRF TBLPTRU, ACCESS
610:               EECON1 = 0x94;  //Prepare for flash erase operation
0460  0E94     MOVLW 0x94
0462  6EA6     MOVWF EECON1, ACCESS
611:               UnlockAndActivate(CORRECT_UNLOCK_KEY);
0464  0100     MOVLB 0x0
0466  0EB5     MOVLW 0xB5
0468  6FF4     MOVWF UnlockKey, BANKED
046A  D8E8     RCALL UnlockAndActivate
612:               
613:               //Now re-program the values from the RAM buffer into the flash memory.  Use
614:               //reverse order, so we program the larger addresses first.  This way, the 
615:               //write page with the flash signature word is the last page that gets 
616:               //programmed (assuming the flash signature resides on the lowest address
617:               //write page, which is recommended, so that it becomes the first page
618:               //erased, and the last page programmed).
619:               TBLPTR = (APP_SIGNATURE_ADDRESS & ERASE_PAGE_ADDRESS_MASK) + ERASE_PAGE_SIZE - 1;   //Point to last byte on the erase page
046C  0E3F     MOVLW 0x3F
046E  6EF6     MOVWF TBLPTRL, ACCESS
0470  0E10     MOVLW 0x10
0472  6EF7     MOVWF TBLPTRH, ACCESS
0474  6AF8     CLRF TBLPTRU, ACCESS
620:               i = ERASE_PAGE_SIZE - 1;
0476  0100     MOVLB 0x0
0478  0E3F     MOVLW 0x3F
047A  6FEE     MOVWF i, BANKED
621:               while(1)
04B4  D7E3     BRA 0x47C
622:               {
623:                   TABLAT = ProgrammingBuffer[i];
047C  0100     MOVLB 0x0
047E  51EE     MOVF i, W, BANKED
0480  6AEA     CLRF FSR0H, ACCESS
0482  0F60     ADDLW 0x60
0484  6EE9     MOVWF FSR0L, ACCESS
0486  0E02     MOVLW 0x2
0488  22EA     ADDWFC FSR0H, F, ACCESS
048A  50EF     MOVF INDF0, W, ACCESS
048C  6EF5     MOVWF TABLAT, ACCESS
624:                   _asm tblwt _endasm
048E  000C     TBLWT*
625:           
626:                   //Check if we are at a program write block size boundary
627:                   if((i % WRITE_BLOCK_SIZE) == 0)
0490  0100     MOVLB 0x0
0492  51EE     MOVF i, W, BANKED
0494  0B1F     ANDLW 0x1F
0496  E107     BNZ 0x4A6
628:                   {
629:                       //The write latches are full, time to program the block.
630:                       ClearWatchdog();
0498  D8E4     RCALL ClearWatchdog
631:                       EECON1 = 0xA4;  //Write to flash on next WR = 1 operation
049A  0EA4     MOVLW 0xA4
049C  6EA6     MOVWF EECON1, ACCESS
632:                       UnlockAndActivate(CORRECT_UNLOCK_KEY);
049E  0100     MOVLB 0x0
04A0  0EB5     MOVLW 0xB5
04A2  6FF4     MOVWF UnlockKey, BANKED
04A4  D8CB     RCALL UnlockAndActivate
633:                   }    
634:                   _asm tblrdpostdec _endasm   //Move TBLPTR back to next location
04A6  000A     TBLRD*-
635:                   
636:                   //Check if we are done writing all blocks
637:                   if(i == 0)
04A8  0100     MOVLB 0x0
04AA  51EE     MOVF i, W, BANKED
04AC  E101     BNZ 0x4B0
638:                   {
639:                       break;  //Exit while loop
04AE  D003     BRA 0x4B6
640:                   }    
641:                   i--;
04B0  0100     MOVLB 0x0
04B2  07EE     DECF i, F, BANKED
642:               }    
643:           }    
04B6  0012     RETURN 0
644:           
645:           
646:           //Before resetting the microcontroller, we should shut down the USB module 
647:           //gracefully, to make sure the host correctly recognizes that we detached
648:           //from the bus.  Some USB hosts malfunction/fail to re-enumerate the device
649:           //correctly if the USB device does not stay detached for a minimum amount of
650:           //time before re-attaching to the USB bus.  For reliable operation, the USB
651:           //device should stay detached for as long as a human would require to unplug and
652:           //reattach a USB device (ex: 100ms+), to ensure the USB host software has a 
653:           //chance to process the detach event and configure itself for a state ready for 
654:           //a new attachment event.
655:           void ResetDeviceCleanly(void)
656:           {
657:               DisableUSBandExecuteLongDelay();
04B8  D804     RCALL DisableUSBandExecuteLongDelay
658:           	Reset();    
04BA  00FF     RESET
659:           	Nop();
04BC  0000     NOP
660:           	Nop();
04BE  0000     NOP
661:           }    
04C0  0012     RETURN 0
662:           
663:           
664:           void DisableUSBandExecuteLongDelay(void)
665:           {
666:               uint_delay_counter = 65535;
04C2  0102     MOVLB 0x2
04C4  69B8     SETF 0xB8, BANKED
04C6  69B9     SETF 0xB9, BANKED
667:               while(uint_delay_counter--)
04C8  0102     MOVLB 0x2
04CA  C2B8     MOVFF uint_delay_counter, __tmp_0
04CC  F000     NOP
04CE  C2B9     MOVFF 0x2B9, 0x1
04D0  F001     NOP
04D2  07B8     DECF 0xB8, F, BANKED
04D4  0E00     MOVLW 0x0
04D6  5BB9     SUBWFB 0xB9, F, BANKED
04D8  5000     MOVF __tmp_0, W, ACCESS
04DA  1001     IORWF 0x1, W, ACCESS
04DC  E004     BZ 0x4E6
04E4  D7F1     BRA 0x4C8
668:               {
669:                   UCONbits.SUSPND = 0;    //Make sure not in suspend mode
04DE  926D     BCF UCON, 1, ACCESS
670:                   UCON = 0x00;            //Disable module (this doens't need to be done in the loop, but we add it to deliberately make the loop execute slower)
04E0  6A6D     CLRF UCON, ACCESS
671:                   ClearWatchdog();
04E2  D8BF     RCALL ClearWatchdog
672:               }   
673:           }    
04E6  0012     RETURN 0
674:           
675:           
676:           void WriteFlashBlock(void)		//Use to write blocks of data to flash.
677:           {
678:               static unsigned char i;
679:           	static unsigned char BytesTakenFromBuffer;
680:           	static unsigned char CorrectionFactor;
681:           
682:               BytesTakenFromBuffer = 0;
04E8  0100     MOVLB 0x0
04EA  6BF0     CLRF BytesTakenFromBuffer, BANKED
683:           	TBLPTR = (ProgrammedPointer - BufferedDataIndex);
04EC  C0E8     MOVFF BufferedDataIndex, __tmp_0
04EE  F000     NOP
04F0  6A01     CLRF 0x1, ACCESS
04F2  6A02     CLRF 0x2, ACCESS
04F4  5000     MOVF __tmp_0, W, ACCESS
04F6  0100     MOVLB 0x0
04F8  5DE9     SUBWF ProgrammedPointer, W, BANKED
04FA  6EF6     MOVWF TBLPTRL, ACCESS
04FC  5001     MOVF 0x1, W, ACCESS
04FE  0100     MOVLB 0x0
0500  59EA     SUBWFB 0xEA, W, BANKED
0502  6EF7     MOVWF TBLPTRH, ACCESS
0504  5002     MOVF 0x2, W, ACCESS
0506  0100     MOVLB 0x0
0508  59EB     SUBWFB 0xEB, W, BANKED
050A  6EF8     MOVWF TBLPTRU, ACCESS
684:           
685:           	//Check the lower 5 bits of the TBLPTR to verify it is pointing to a 32 byte aligned block (5 LSb = 00000).
686:           	//If it isn't, need to somehow make it so before doing the actual loading of the programming latches.
687:           	//In order to maximize programming speed, the PC application meant to be used with this firmware will not send 
688:           	//large blocks of 0xFF bytes.  If the PC application
689:           	//detects a large block of unprogrammed space in the hex file (effectively = 0xFF), it will skip over that
690:           	//section and will not send it to the firmware.  This works, because the firmware will have already done an
691:           	//erase on that section of memory when it received the ERASE_DEVICE command from the PC.  Therefore, the section
692:           	//can be left unprogrammed (after an erase the flash ends up = 0xFF).
693:           	//This can result in a problem however, in that the next genuine non-0xFF section in the hex file may not start 
694:           	//on a 32 byte aligned block boundary.  This needs to be handled with care since the microcontroller can only 
695:           	//program 32 byte blocks that are aligned with 32 byte boundaries.
696:           	//So, use the below code to avoid this potential issue.
697:           
698:           	#if(WRITE_BLOCK_SIZE == 0x20)
699:           		CorrectionFactor = (TBLPTRL & 0b00011111);	//Correctionfactor = number of bytes tblptr must go back to find the immediate preceeding 32 byte boundary
050C  0E1F     MOVLW 0x1F
050E  14F6     ANDWF TBLPTRL, W, ACCESS
0510  0100     MOVLB 0x0
0512  6FF1     MOVWF CorrectionFactor, BANKED
700:           		TBLPTRL &= 0b11100000;						//Move the table pointer back to the immediately preceeding 32 byte boundary
0514  0EE0     MOVLW 0xE0
0516  16F6     ANDWF TBLPTRL, F, ACCESS
701:           	#elif(WRITE_BLOCK_SIZE == 0x10)
702:           		CorrectionFactor = (TBLPTRL & 0b00001111);	//Correctionfactor = number of bytes tblptr must go back to find the immediate preceeding 16 byte boundary
703:           		TBLPTRL &= 0b11110000;						//Move the table pointer back to the immediately preceeding 16 byte boundary
704:           	#elif(WRITE_BLOCK_SIZE == 0x8)
705:           		CorrectionFactor = (TBLPTRL & 0b00000111);	//Correctionfactor = number of bytes tblptr must go back to find the immediate preceeding 16 byte boundary
706:           		TBLPTRL &= 0b11111000;						//Move the table pointer back to the immediately preceeding 16 byte boundary
707:           	#else
708:           		#error Double click this error message and fix this section for your microcontroller type.
709:           	#endif
710:           
711:           	for(i = 0; i < WRITE_BLOCK_SIZE; i++)	//Load the programming latches
0518  0100     MOVLB 0x0
051A  6BEF     CLRF i, BANKED
051C  0E20     MOVLW 0x20
051E  0100     MOVLB 0x0
0520  5DEF     SUBWF i, W, BANKED
0522  E21F     BC 0x562
055C  0100     MOVLB 0x0
055E  2BEF     INCF i, F, BANKED
0560  D7DD     BRA 0x51C
712:           	{
713:           		if(CorrectionFactor == 0)
0524  0100     MOVLB 0x0
0526  51F1     MOVF CorrectionFactor, W, BANKED
0528  E115     BNZ 0x554
714:           		{
715:           			if(BufferedDataIndex != 0)	//If the buffer isn't empty
052A  0100     MOVLB 0x0
052C  51E8     MOVF BufferedDataIndex, W, BANKED
052E  E00F     BZ 0x54E
716:           			{
717:           				TABLAT = ProgrammingBuffer[BytesTakenFromBuffer];
0530  0100     MOVLB 0x0
0532  51F0     MOVF BytesTakenFromBuffer, W, BANKED
0534  6AEA     CLRF FSR0H, ACCESS
0536  0F60     ADDLW 0x60
0538  6EE9     MOVWF FSR0L, ACCESS
053A  0E02     MOVLW 0x2
053C  22EA     ADDWFC FSR0H, F, ACCESS
053E  50EF     MOVF INDF0, W, ACCESS
0540  6EF5     MOVWF TABLAT, ACCESS
718:           				_asm tblwtpostinc _endasm
0542  000D     TBLWT*+
719:           				BytesTakenFromBuffer++;
0544  0100     MOVLB 0x0
0546  2BF0     INCF BytesTakenFromBuffer, F, BANKED
720:           				BufferedDataIndex--;	//Used up a byte from the buffer.
0548  0100     MOVLB 0x0
054A  07E8     DECF BufferedDataIndex, F, BANKED
721:           			}
722:           			else	//No more data in buffer, need to write 0xFF to fill the rest of the programming latch locations
054C  D002     BRA 0x552
723:           			{
724:           				TABLAT = 0xFF;
054E  68F5     SETF TABLAT, ACCESS
725:           				_asm tblwtpostinc _endasm				
0550  000D     TBLWT*+
726:           			}
727:           		}
728:           		else
0552  D004     BRA 0x55C
729:           		{
730:           			TABLAT = 0xFF;
0554  68F5     SETF TABLAT, ACCESS
731:           			_asm tblwtpostinc _endasm
0556  000D     TBLWT*+
732:           			CorrectionFactor--;
0558  0100     MOVLB 0x0
055A  07F1     DECF CorrectionFactor, F, BANKED
733:           		}
734:           	}
735:           
736:               //	TBLPTR--;		        //Need to make table pointer point to the region which will be programmed before initiating the programming operation
737:           	_asm tblrdpostdec _endasm	//Do this instead of TBLPTR--; since it takes less code space.
0562  000A     TBLRD*-
738:           		
739:           	EECON1 = 0b10100100;	//flash programming mode
0564  0EA4     MOVLW 0xA4
0566  6EA6     MOVWF EECON1, ACCESS
740:           	UnlockAndActivate(CORRECT_UNLOCK_KEY);
0568  0100     MOVLB 0x0
056A  0EB5     MOVLW 0xB5
056C  6FF4     MOVWF UnlockKey, BANKED
056E  D866     RCALL UnlockAndActivate
741:           
742:           	//Now need to fix the ProgrammingBuffer[].  We may not have taken a full 32 bytes out of the buffer.  In this case,
743:           	//the data is no longer justified correctly.
744:           	for(i = 0; i < BufferedDataIndex; i++)	//Need to rejustify the remaining data to the "left" of the buffer (if there is any left)
0570  0100     MOVLB 0x0
0572  6BEF     CLRF i, BANKED
0574  0100     MOVLB 0x0
0576  51E8     MOVF BufferedDataIndex, W, BANKED
0578  0100     MOVLB 0x0
057A  5DEF     SUBWF i, W, BANKED
057C  E218     BC 0x5AE
05A8  0100     MOVLB 0x0
05AA  2BEF     INCF i, F, BANKED
05AC  D7E3     BRA 0x574
745:           	{
746:           		ProgrammingBuffer[i] = ProgrammingBuffer[BytesTakenFromBuffer+i];
057E  0100     MOVLB 0x0
0580  51F0     MOVF BytesTakenFromBuffer, W, BANKED
0582  0100     MOVLB 0x0
0584  25EF     ADDWF i, W, BANKED
0586  6AEA     CLRF FSR0H, ACCESS
0588  0F60     ADDLW 0x60
058A  6EE9     MOVWF FSR0L, ACCESS
058C  0E02     MOVLW 0x2
058E  22EA     ADDWFC FSR0H, F, ACCESS
0590  50EF     MOVF INDF0, W, ACCESS
0592  6EE6     MOVWF POSTINC1, ACCESS
0594  0100     MOVLB 0x0
0596  51EF     MOVF i, W, BANKED
0598  6AEA     CLRF FSR0H, ACCESS
059A  0F60     ADDLW 0x60
059C  6EE9     MOVWF FSR0L, ACCESS
059E  0E02     MOVLW 0x2
05A0  22EA     ADDWFC FSR0H, F, ACCESS
05A2  52E5     MOVF POSTDEC1, F, ACCESS
05A4  50E7     MOVF INDF1, W, ACCESS
05A6  6EEF     MOVWF INDF0, ACCESS
747:           	}
748:           }
05AE  0012     RETURN 0
749:           
750:           
751:           void WriteConfigBits(void)	//Also used to write the Device ID
752:           {
753:           	static unsigned char i;
754:           
755:           	TBLPTR = (unsigned short long)PacketFromPC.Address;
05B0  C0A2     MOVFF 0xA2, TBLPTRL
05B2  FFF6     NOP
05B4  C0A3     MOVFF 0xA3, TBLPTRH
05B6  FFF7     NOP
05B8  C0A4     MOVFF 0xA4, TBLPTRU
05BA  FFF8     NOP
756:           
757:           	for(i = 0; i < PacketFromPC.Size; i++)
05BC  0100     MOVLB 0x0
05BE  6BF2     CLRF i, BANKED
05C0  0100     MOVLB 0x0
05C2  51A6     MOVF 0xA6, W, BANKED
05C4  0100     MOVLB 0x0
05C6  5DF2     SUBWF i, W, BANKED
05C8  E218     BC 0x5FA
05F4  0100     MOVLB 0x0
05F6  2BF2     INCF i, F, BANKED
05F8  D7E3     BRA 0x5C0
758:           	{
759:           		TABLAT = PacketFromPC.Data[i+(REQUEST_DATA_BLOCK_SIZE-PacketFromPC.Size)];
05CA  0E3A     MOVLW 0x3A
05CC  0100     MOVLB 0x0
05CE  80D8     BSF STATUS, 0, ACCESS
05D0  55A6     SUBFWB 0xA6, W, BANKED
05D2  0100     MOVLB 0x0
05D4  25F2     ADDWF i, W, BANKED
05D6  6AEA     CLRF FSR0H, ACCESS
05D8  0FA7     ADDLW 0xA7
05DA  6EE9     MOVWF FSR0L, ACCESS
05DC  0E00     MOVLW 0x0
05DE  22EA     ADDWFC FSR0H, F, ACCESS
05E0  50EF     MOVF INDF0, W, ACCESS
05E2  6EF5     MOVWF TABLAT, ACCESS
760:           		_asm
761:           		tblwt
05E4  000C     TBLWT*
762:           		_endasm
763:           
764:           		EECON1 = 0b11000100;	//Config bits programming mode
05E6  0EC4     MOVLW 0xC4
05E8  6EA6     MOVWF EECON1, ACCESS
765:           		UnlockAndActivate(CORRECT_UNLOCK_KEY);
05EA  0100     MOVLB 0x0
05EC  0EB5     MOVLW 0xB5
05EE  6FF4     MOVWF UnlockKey, BANKED
05F0  D825     RCALL UnlockAndActivate
766:           
767:           		_asm
768:           		tblrdpostinc
05F2  0009     TBLRD*+
769:           		_endasm
770:           	}
771:           }
05FA  0012     RETURN 0
772:           
773:           #if defined(DEVICE_WITH_EEPROM)
774:           void WriteEEPROM(void)
775:           {
776:           	static unsigned char i;
777:           	
778:           	for(i = 0; i < PacketFromPC.Size; i++)
05FC  0100     MOVLB 0x0
05FE  6BF3     CLRF i, BANKED
0600  0100     MOVLB 0x0
0602  51A6     MOVF 0xA6, W, BANKED
0604  0100     MOVLB 0x0
0606  5DF3     SUBWF i, W, BANKED
0608  E218     BC 0x63A
0634  0100     MOVLB 0x0
0636  2BF3     INCF i, F, BANKED
0638  D7E3     BRA 0x600
779:           	{
780:           		EEADR = (((unsigned char)PacketFromPC.Address) + i);
060A  0100     MOVLB 0x0
060C  51A2     MOVF 0xA2, W, BANKED
060E  0100     MOVLB 0x0
0610  25F3     ADDWF i, W, BANKED
0612  6EA9     MOVWF EEADR, ACCESS
781:           		EEDATA = PacketFromPC.Data[i+(REQUEST_DATA_BLOCK_SIZE-PacketFromPC.Size)];
0614  0E3A     MOVLW 0x3A
0616  0100     MOVLB 0x0
0618  80D8     BSF STATUS, 0, ACCESS
061A  55A6     SUBFWB 0xA6, W, BANKED
061C  0100     MOVLB 0x0
061E  25F3     ADDWF i, W, BANKED
0620  6AEA     CLRF FSR0H, ACCESS
0622  0FA7     ADDLW 0xA7
0624  6EE9     MOVWF FSR0L, ACCESS
0626  0E00     MOVLW 0x0
0628  22EA     ADDWFC FSR0H, F, ACCESS
062A  50EF     MOVF INDF0, W, ACCESS
062C  6EA8     MOVWF EEDATA, ACCESS
782:           
783:           		EECON1 = 0b00000100;	//EEPROM Write mode
062E  0E04     MOVLW 0x4
0630  6EA6     MOVWF EECON1, ACCESS
784:           		UnlockAndActivate(CORRECT_UNLOCK_KEY);
0632  D823     RCALL __pa_1
067A  0100     MOVLB 0x0
067C  0EB5     MOVLW 0xB5
067E  6FF4     MOVWF UnlockKey, BANKED
0680  EF1E     GOTO 0x63C
0682  F003     NOP
785:           	}
786:           
787:           }
063A  0012     RETURN 0
788:           #endif
789:           
790:           //It is preferrable to only place this sequence in only one place in the flash memory.
791:           //This reduces the probabilty of the code getting executed inadvertently by
792:           //errant code.  It is also recommended to enable BOR (in hardware) and/or add
793:           //software checks to avoid microcontroller "overclocking".  Always make sure
794:           //to obey the voltage versus frequency graph in the datasheet, even during
795:           //momentary events (such as the power up and power down ramp of the microcontroller).
796:           void UnlockAndActivate(unsigned char UnlockKey)
797:           {
798:           	INTCONbits.GIE = 0;		//Make certain interrupts disabled for unlock process.
063C  9EF2     BCF INTCON, 7, ACCESS
799:           
800:               //Check to make sure the caller really was trying to call this function.
801:               //If they were, they should always pass us the CORRECT_UNLOCK_KEY.
802:               if(UnlockKey != CORRECT_UNLOCK_KEY)
063E  0EB5     MOVLW 0xB5
0640  0100     MOVLB 0x0
0642  5DF4     SUBWF UnlockKey, W, BANKED
0644  E005     BZ 0x650
803:               {
804:                   //Warning!  Errant code execution detected.  Somehow this 
805:                   //UnlockAndActivate() function got called by someone that wasn't trying
806:                   //to actually perform an NVM erase or write.  This could happen due to
807:                   //microcontroller overclocking (or undervolting for an otherwise allowed
808:                   //CPU frequency), or due to buggy code (ex: incorrect use of function 
809:                   //pointers, etc.).  In either case, we should execute some fail safe 
810:                   //code here to prevent corruption of the NVM contents.
811:                   OSCCON = 0x03;  //Switch to INTOSC at low frequency
0646  0E03     MOVLW 0x3
0648  6ED3     MOVWF OSCCON, ACCESS
812:                   while(1)
064C  D7FE     BRA 0x64A
813:                   {
814:                       Sleep();
064A  0003     SLEEP
815:                   }    
816:                   Reset();
064E  00FF     RESET
817:               }    
818:               
819:           	_asm
820:           	//Now unlock sequence to set WR (make sure interrupts are disabled before executing this)
821:           	MOVLW 0x55
0650  0E55     MOVLW 0x55
822:           	MOVWF EECON2, 0
0652  6EA7     MOVWF EECON2, ACCESS
823:           	MOVLW 0xAA
0654  0EAA     MOVLW 0xAA
824:           	MOVWF EECON2, 0
0656  6EA7     MOVWF EECON2, ACCESS
825:           	BSF EECON1, 1, 0		//Performs write
0658  82A6     BSF EECON1, 1, ACCESS
826:           	_endasm	
827:           	while(EECON1bits.WR);	//Wait until complete (relevant when programming EEPROM, not important when programming flash since processor stalls during flash program)	
065A  B2A6     BTFSC EECON1, 1, ACCESS
065C  D7FE     BRA 0x65A
828:           	EECON1bits.WREN = 0;  	//Good practice now to clear the WREN bit, as further protection against any accidental activation of self write/erase operations.
065E  94A6     BCF EECON1, 2, ACCESS
829:           }	
0660  0012     RETURN 0
830:           
831:           
832:           //Note: The ClrWdt() and "_asm tblrdpostinc _endasm" are inline assembly language
833:           //instructions.  The ClearWatchdog() and  TableReadPostIncrement() functions are 
834:           //theoretically extraneous, since the operations being accomplished could be
835:           //done without calling them as separate functions.  However, when using inline
836:           //assembly language, the C compiler normally doesn't know what the code will
837:           //actually do (ex: will it modify STATUS reg, WREG, BSR contents??).  As a 
838:           //result, it is potentially dangerous for the C compiler to make assumptions,
839:           //that might turn out not to be correct.  Therefore, the C18 compiler disables
840:           //the compiler optimizations for a function, when one or more inline asm 
841:           //instructions are located within the C function.  Therefore, to promote best
842:           //code size optimizations from the C compiler, it is best to locate inline
843:           //assembly sequences in their own separate C functions, that do not contain much
844:           //other code (which could otherwise be optimized by the C compiler).  This often
845:           //results in the smallest code size, and is the reason it is being done here.
846:           void ClearWatchdog(void)
847:           {
848:               ClrWdt();
0662  0004     CLRWDT
849:           }    
0664  0012     RETURN 0
850:           void TableReadPostIncrement(void)
851:           {
852:           	_asm tblrdpostinc _endasm    
0666  0009     TBLRD*+
853:           }    
0668  0012     RETURN 0
854:           
855:           
856:           
857:           /** EOF BootPIC18NonJ.c *********************************************************/
