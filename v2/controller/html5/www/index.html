<!DOCTYPE html>

<html>
<head>
    <title>e-minor v2 MIDI foot controller</title>
    <script type="text/javascript" src="eminorv2.js"></script>
    <script type="text/javascript" src="driver.js"></script>
    <style type="text/css">
        body {
            background: #020208;
            color: silver;
            font-family: 'lucida grande', tahoma, verdana, arial, sans-serif;
            font-size: 13px;
        }

        h1, h3 {
            text-align: center;
            padding: 0;
            margin: 0;
        }

        h5 {
            padding: 0;
            margin: 0;
        }

        canvas {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            outline: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0); /* mobile webkit */
        }

        dl {
            margin-bottom: 1em;
        }

            dl dt {
                background: #101020;
                color: #fff;
                clear: left;
                float: left;
                margin-top: 2px;
                margin-right: 10px;
                padding: 12px;
                width: 100px;
            }

            dl dd {
                margin: 2px 0;
                padding: 0px 0;
            }
    </style>
</head>
<body>
    <h1>e-minor v2 MIDI foot controller</h1>
    <h3>Software designed by <a href="https://github.com/JamesDunne" target="_blank">James S. Dunne</a></h3>
    <h3>Hardware/firmware designed by <a href="https://github.com/jdunne525" target="_blank">Joseph R. Dunne</a></h3>
    <h5 style="text-align: center"><a href="https://github.com/JamesDunne/eminor2/tree/master/v2" target="_blank">https://github.com/JamesDunne/eminor2/tree/master/v2</a></h5>
    <h5 style="text-align: center">Last updated: 2013-11-19</h5>

    <h2>What is it?</h2>
    <p>
        The e-minor v2 is an open-source and open-hardware project describing a custom programmable floorboard controller designed to send MIDI commands to musical instrument devices with a focus on controlling guitar amplifier and effects equipment.
        MIDI is still in widespread use with electric guitar equipment, despite the standard's age; most moderately advanced devices support it. There are also many MIDI adapter systems which can translate MIDI commands into more primitive switch signals,
        e.g. <a href="http://www.rjmmusic.com/" target="_blank">RJM Technologies'</a> products like the Amp Gizmo and Mini Amp Gizmo.
    </p>
    <p>The <a href="https://github.com/JamesDunne/eminor2/tree/master/v2" target="_blank">GitHub repository</a> contains everything you'd need to build your own, e.g. all of the controller source code, the MPLAB PIC18 project, the hardware schematic, and even PCB layout.</p>

    <p>Our device is designed with 2 rows of 8 rugged foot switches, each paired with an indicator LED. The function of these foot switches and LEDs is entirely up to the programmer to decide.</p>
    <p>At the back of the device is a MIDI OUT port, a USB-B port, a power switch, and a 9V DV jack. We like to keep things simple here.</p>

    <h2>Function</h2>
    <p>Although this project aims to be a useful template for constructing any programmable MIDI controller, I have a concrete implementation with controller logic specific to my guitar rig equipment to fit my needs.</p>
    <p>
        My rig consists of a MESA/Boogie&trade; Mark V amplifier head, an RJM Mini Amp Gizmo, and a t.c. electronics g-major rack effects unit. Since the Mark V itself is not MIDI-enabled, I use the Mini Amp Gizmo to translate MIDI commands into more
        primitive on/off signals sent to the Mark V head via its floorboard jack. Essentially, the Mini Amp Gizmo is acting as a floorboard controller for the Mark V but is MIDI controlled.
        The g-major is also MIDI controllable and can switch presets or enable/disable certain effects depending on the MIDI commands sent to it.
        The current e-minor controller logic is designed to send program change messages to both devices listening on separate channels (g-major on channel 1, RJM on channel 2). This way the two devices don't get confused listening to each others' commands.
    </p>
    <p>
        I believe most things can best be explained by example, so feel free to play with the live HTML5 example below to get a feel for the controller logic! Use keyboard keys or your mouse to depress the foot switches. The MIDI OUT window shows what
        MIDI commands would be sent.
    </p>

    <!-- Live demo here: -->
    <div style="text-align: center; margin-left: 2em; margin-right: 2em; white-space: nowrap">
        <div style="display: inline-block; vertical-align: top; margin-right: 1em">
            <canvas id="cvs" tabindex="1"></canvas><br />
            <span>(click to focus; use keyboard QWERTYUI and ASDFGHJK or mouse)</span>
        </div>
        <div style="display: inline-block; vertical-align: top; width: 16em; text-align: left; white-space: normal">
            <h5>MIDI OUT:</h5>
            <pre id="midiLog" style="height: 240px; width: 14em"></pre>
            <p><strong>NOTE:</strong> These commands are not actually sent to a MIDI device because that is not easily accomplished from a browser.</p>
        </div>
    </div>

    <div style="text-align: center; margin-left: 2em; margin-right: 2em; white-space: nowrap">
        <div style="display: inline-block; text-align: left; margin-right: 4em; width: 32em; white-space: normal; ">
            <h5>MIDI commands:</h5>
            <dl>
                <dt><strong>C</strong><em>c aa</em></dt>
                <dd>A program change message sent to channel <em>c</em>; program number is <em>aa</em></dd>
                <dt><strong>B</strong><em>c aa bb</em></dt>
                <dd>A continuous controller change message sent to channel <em>c</em>; <em>aa</em> is the controller number; <em>bb</em> is the controller value</dd>
            </dl>
        </div>
        <div style="display: inline-block; text-align: left; width: 32em; white-space: normal; ">
            <p>
                The MIDI data is displayed in hexadecimal which means only two characters are needed to display values in the range 0-255. Each hex digit represents exactly 4 bits of data so each pairing of digits represents exactly 8 bits.
                This is just a convenient notation for programmers and engineers to use since it is more aligned with the binary system, much more so than decimal digits are.
            </p>
        </div>
    </div>

    <p>The top row of foot switches enables/disables effects on the g-major.</p>
    <p>
        The bottom row of foot switches switches amplifier channels on the Mark V via the RJM. It also reloads the current g-major program in order to reset all effects back to their original on/off state. The Mark V is a 3-channel amplifier and also
        has a SOLO mode that gives a nice volume boost when desired. The foot switches alternate enabling the SOLO mode per channel. This configuration is more useful to me than having an independent SOLO foot switch since usually I want to go straight to a
        specific soloed sound and not spend two clicks to get there when I can get there in just one.
    </p>
    <p>The MUTE foot switch toggles the g-major input mute, useful for entering a silent tuning mode while on stage.</p>
    <p>The TAP foot switch sends the g-major a TAP TEMPO function, useful for keeping time-related effects in sync with the song's tempo.</p>
    <p>The NEXT/PREV foot switches change the g-major program. I have the g-major programmed with per-song effects settings and use the NEXT/PREV to move to the song I'm currently playing.</p>

    <h2>Firmware</h2>
    <p>The primary controller logic for the project is written in entirely portable ISO C99 (C) code. The controller logic expects a hardware interface layer consisting of several functions to be implemented in the host.</p>
    <p>
        As of now, there are three hosts implemented for the portable controller logic written in C:
        <ul>
            <li>This HTML5 javascript demo compiled from the C code using <a href="https://github.com/kripken/emscripten/wiki" target="_blank">Emscripten</a></li>
            <li>A <a href="https://github.com/JamesDunne/eminor2/tree/master/v2/controller/Win32" target="_blank">Windows desktop application</a> test harness (see the readme.txt) which actually sends MIDI messages for testing</li>
            <li>PIC18 microcontroller firmware controlled by physical foot switches</li>
        </ul>
        How's that for cross-platform portability?
    </p>

    <h2>Hardware</h2>
    <p>The project is designed to run on a PIC18, an 8-bit microprocessor. The TX pin (from the UART of the PIC18) is used to send MIDI data via the MIDI OUT port. The PIC18 also natively supports USB and our firmware allows one to easily reprogram the PIC via USB.</p>
    <p>We used CADSoft Eagle to design the schematic and PCB. You can find all the project files here: <a href="https://github.com/JamesDunne/eminor2/tree/master/v2/pcb" target="_blank">https://github.com/JamesDunne/eminor2/tree/master/v2/pcb</a></p>
    <p>Here is a screenshot the schematic:</p>
    <div style="text-align: center; margin-top: 1em">
        <a href="https://github.com/JamesDunne/eminor2/raw/master/v2/pcb/schematic.png" target="_blank"><img src="https://raw.github.com/JamesDunne/eminor2/master/v2/pcb/schematic.png" alt="Schematic" style="max-width: 600px" /></a><br />
        <span>(click for larger version)</span>
    </div>
    <p>I took the liberty of designing a PCB layout for the schematic as well. Unfortunately, due to PCB size constraints, some pin-mapping sins had to be committed so that the traces and ICs could all fit happily on the board. Look at the pin headers to see what I mean.</p>
    <div style="text-align: center; margin-top: 1em">
        <a href="https://github.com/JamesDunne/eminor2/raw/master/v2/pcb/pcb.png" target="_blank"><img src="https://github.com/JamesDunne/eminor2/raw/master/v2/pcb/pcb.png" alt="PCB Layout" style="max-width: 600px" /></a><br />
        <span>(click for larger version)</span>
    </div>

    <h2>Bill of Materials</h2>
    <p>
        The foot switches we use come from <a href="http://www.bitcheslovemyswitches.com/#!/%7E/product/category=5027572&id=10220659" target="_blank">bitcheslovemyswitches.com</a>.
        Shout out to <a href="https://twitter.com/LawrenceScaduto" target="_blank">Lawrence Scaduto</a>, owner and proprietor, for being a big help in fulfilling my initial order!
    </p>
    <p>The chassis we use is <a href="http://www.hammondmfg.com/dwg16.htm#15degree" target="_blank">Hammond Mfg.'s 1456WH3BKBU</a>, an aluminum sloped console with a usable surface area of 20.078" x 6.305" on the sloped face, perfect for a floorboard controller. On their datasheet they claim they can do factory modifications (drilling, milling, printing). I just might be interested in that... Definitely not looking forward to drilling holes manually for foot switches and LEDs.</p>
    <p>Our schematic does a good job of labelling all the values for the resistors and capacitors so there should be no problem there.</p>
    <p>I found MIDI and USB-B PCB-mounted parts at <a href="https://www.sparkfun.com/" target="_blank">sparkfun.com</a>.</p>
    <p>I'm still working out the remaining components for the PCB but in the mean time you can go to this <a href="https://docs.google.com/spreadsheet/ccc?key=0Ah4nh0yGtjrgdHBYRjlqZkN1UXhrbTFLOTFnZWNGYkE#gid=0" target="_blank">Google Docs Spreadsheet</a> to see the work-in-progress.</p>

    <h2>More to come!</h2>
    <p>There's still much more to come as I'll be getting all the components put together and assembling the device myself in the next few weeks. Stay tuned!</p>
</body>
</html>
